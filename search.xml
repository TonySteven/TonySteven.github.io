<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[问题总结]]></title>
    <url>%2F2017%2F11%2F27%2Fresumeexec%2F</url>
    <content type="text"><![CDATA[删除列表重复元素123def deleteDuplicatedElementFromList3(listA): #return list(set(listA)) return sorted(set(listA), key = listA.index) python中拷贝一个对象 如果需要拷贝对象，需要使用标准库中的copy模块 12import copynew_list = copy.copy(existing_list) python单例模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138 #coding=utf-8 print &apos;----------------------方法1--------------------------&apos; #方法1,实现__new__方法 #并在将一个类的实例绑定到类变量_instance上, #如果cls._instance为None说明该类还没有实例化过,实例化该类,并返回 #如果cls._instance不为None,直接返回cls._instance class Singleton(object): def __new__(cls, *args, **kw): if not hasattr(cls, &apos;_instance&apos;): orig = super(Singleton, cls) cls._instance = orig.__new__(cls, *args, **kw) return cls._instance class MyClass(Singleton): a = 1 one = MyClass() two = MyClass() two.a = 3 print one.a #3 #one和two完全相同,可以用id(), ==, is检测 print id(one) #29097904 print id(two) #29097904 print one == two #True print one is two #True print &apos;----------------------方法2--------------------------&apos; #方法2,共享属性;所谓单例就是所有引用(实例、对象)拥有相同的状态(属性)和行为(方法) #同一个类的所有实例天然拥有相同的行为(方法), #只需要保证同一个类的所有实例具有相同的状态(属性)即可 #所有实例共享属性的最简单最直接的方法就是__dict__属性指向(引用)同一个字典(dict) #可参看:http://code.activestate.com/recipes/66531/ class Borg(object): _state = &#123;&#125; def __new__(cls, *args, **kw): ob = super(Borg, cls).__new__(cls, *args, **kw) ob.__dict__ = cls._state return ob class MyClass2(Borg): a = 1 one = MyClass2() two = MyClass2() #one和two是两个不同的对象,id, ==, is对比结果可看出 two.a = 3 print one.a #3 print id(one) #28873680 print id(two) #28873712 print one == two #False print one is two #False #但是one和two具有相同的（同一个__dict__属性）,见: print id(one.__dict__) #30104000 print id(two.__dict__) #30104000 print &apos;----------------------方法3--------------------------&apos; #方法3:本质上是方法1的升级（或者说高级）版 #使用__metaclass__（元类）的高级python用法 class Singleton2(type): def __init__(cls, name, bases, dict): super(Singleton2, cls).__init__(name, bases, dict) cls._instance = None def __call__(cls, *args, **kw): if cls._instance is None: cls._instance = super(Singleton2, cls).__call__(*args, **kw) return cls._instance class MyClass3(object): __metaclass__ = Singleton2 one = MyClass3() two = MyClass3() two.a = 3 print one.a #3 print id(one) #31495472 print id(two) #31495472 print one == two #True print one is two #True print &apos;----------------------方法4--------------------------&apos; #方法4:也是方法1的升级（高级）版本, #使用装饰器(decorator), #这是一种更pythonic,更elegant的方法, #单例类本身根本不知道自己是单例的,因为他本身(自己的代码)并不是单例的 def singleton(cls, *args, **kw): instances = &#123;&#125; def _singleton(): if cls not in instances: instances[cls] = cls(*args, **kw) return instances[cls] return _singleton @singleton class MyClass4(object): a = 1 def __init__(self, x=0): self.x = x one = MyClass4() two = MyClass4() two.a = 3 print one.a #3 print id(one) #29660784 print id(two) #29660784 print one == two #True print one is two #True one.x = 1 print one.x #1 print two.x #1 lambda函数 lambda存在意义就是对简单函数的简洁表示 1234561.g = lambda x:x+1or lambda x:x+1(1)meansdef g(x): return x+1 python实现一个stack1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Stack(object): # 初始化栈为空列表 def __init__(self): self.items = [] # 判断栈是否为空，返回布尔值 def is_empty(self): return self.items == [] # 返回栈顶元素 def peek(self): return self.items[len(self.items) - 1] # 返回栈的大小 def size(self): return len(self.items) # 把新的元素堆进栈里面（程序员喜欢把这个过程叫做压栈，入栈，进栈……） def push(self, item): self.items.append(item) # 把栈顶元素丢出去（程序员喜欢把这个过程叫做出栈……） def pop(self, item): return self.items.pop()if __name__ == __main__: # 初始化一个栈对象 my_stack = Stack() # 把&apos;h&apos;丢进栈里 my_stack.push(&apos;h&apos;) # 把&apos;a&apos;丢进栈里 my_stack.push(&apos;a&apos;) # 看一下栈的大小（有几个元素） print my_stack.size() # 打印栈顶元素 print my_stack.peek() # 把栈顶元素丢出去，并打印出来 print my_stack.pop() # 再看一下栈顶元素是谁 print my_stack.peek() # 这个时候栈的大小是多少？ print my_stack.size() # 再丢一个栈顶元素 print my_stack.pop() # 看一下栈的大小 print my_stack.size # 栈是不是空了？ print my_stack.is_empty() # 哇~真好吃~ print &apos;Yummy~&apos; str对象方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657581. 首字母大写capitalize()s.capitalize() 返回s的一份拷贝，并不改变s。如果 s 的首字符是一个字母，则拷贝的首字母将其改成大写，其余所有字母转成小写。例如：&gt;&gt;&gt; &apos;this is a test string.&apos;.capitalize()&apos;This is a test string.&apos;&gt;&gt;&gt; &apos;_this is a test string.&apos;.capitalize()# 开头不是字母，不变&apos;_this is a test string.&apos;&gt;&gt;&gt; &apos;this is A test string.&apos;.capitalize()# 除开头外的其他位置上的字母全转成小写&apos;This is a test string.&apos; 2. 对齐方式（1）左右对齐 ljust()、rjust()s.ljust(width[, fillchar])s.rjust(width[, fillchar]) 返回一个长度为 max(len(s), width) 的字符串，如果 width &gt; len(s)，则左/右对齐，并在另一端填充 fillchar例如：&gt;&gt;&gt; &apos;1234&apos;.rjust(8, &apos;#&apos;)&apos;####1234&apos;&gt;&gt;&gt; &apos;1234&apos;.ljust(8, &apos;#&apos;)&apos;1234####&apos;&gt;&gt;&gt; &apos;1234&apos;.ljust(2, &apos;#&apos;)&apos;1234&apos;（2）居中 center()s.center(n, fillchar=&apos; &apos;) 返回一个新的字符串，新字符串的长度为 max(len(s), n)，当 n &gt; len(s)时，使用参数 fillchar （默认为空格）填充新字符串中其余的位置，并将 s 置于新字符串的中部。例如：&gt;&gt;&gt; &apos;test&apos;.center(3)&apos;test&apos;&gt;&gt;&gt; &apos;test&apos;.center(5)&apos; test&apos;&gt;&gt;&gt; &apos;test&apos;.center(6, &apos;#&apos;)&apos;#test#&apos;&gt;&gt;&gt; &apos;test&apos;.center(7, &apos;~&apos;)&apos;~~test~&apos; 可见当左右无法均衡填充时，优先填充左侧。 3. 计数count()s.count(sub, start=0, end=sys.maxint) 统计 s[start:end] 中，子串 sub 出现的次数。 http请求头,常见的响应状态码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778HTTP由两部分组成：请求和响应。当你在Web浏览器中输入一个URL时，浏览器将根据你的要求创建并发送请求，该请求包含所输入的URL以及一些与浏览器本身相关的信息。当服务器收到这个请求时将返回一个响应，该响应包括与该请求相关的信息以及位于指定URL（如果有的话）的数据。直到浏览器解析该响应并显示出网页（或其他资源）为止。HTTP请求HTTP请求的格式如下所示：&lt;request-line&gt;&lt;headers&gt;&lt;blank line&gt;[&lt;request-body&gt;]在HTTP请求中，第一行必须是一个请求行（request line），用来说明请求类型、要访问的资源以及使用的HTTP版本。紧接着是一个首部（header）小节，用来说明服务器要使用的附加信息。在首部之后是一个空行，再此之后可以添加任意的其他数据[称之为主体（body）]。在HTTP中，定义了多种请求类型，通常我们关心的只有GET请求和POST请求。只要在Web浏览器上输入一个URL，浏览器就将基于该URL向服务器发送一个GET请求，以告诉服务器获取并返回什么资源。对于www.baidu.com的GET请求如下所示：GET / HTTP/1.1Host: www.baidu.comUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)Gecko/20050225 Firefox/1.0.1Connection: Keep-Alive请求行的第一部分说明了该请求是GET请求。该行的第二部分是一个斜杠（/），用来说明请求的是该域名的根目录。该行的最后一部分说明使用的是HTTP 1.1版本（另一个可选项是1.0）。那么请求发到哪里去呢？这就是第二行的内容。第2行是请求的第一个首部，HOST。首部HOST将指出请求的目的地。结合HOST和上一行中的斜杠（/），可以通知服务器请求的是www.baidu.com/（HTTP 1.1才需要使用首部HOST，而原来的1.0版本则不需要使用）。第三行中包含的是首部User-Agent，服务器端和客户端脚本都能够访问它，它是浏览器类型检测逻辑的重要基础。该信息由你使用的浏览器来定义（在本例中是Firefox 1.0.1），并且在每个请求中将自动发送。最后一行是首部Connection，通常将浏览器操作设置为Keep-Alive（当然也可以设置为其他值）。注意，在最后一个首部之后有一个空行。即使不存在请求主体，这个空行也是必需的。要发送GET请求的参数，则必须将这些额外的信息附在URL本身的后面。其格式类似于：URL ? name1=value1&amp;name2=value2&amp;..&amp;nameN=valueN该信息称之为查询字符串（query string），它将会复制在HTTP请求的请求行中，如下所示：GET /books/?name=Professional%20Ajax HTTP/1.1Host: www.baidu.comUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)Gecko/20050225 Firefox/1.0.1Connection: Keep-Alive注意，为了将文本“Professional Ajax”作为URL的参数，需要编码处理其内容，将空格替换成%20，这称为URL编码（URL encoding），常用于HTTP的许多地方（JavaScript提供了内建的函数来处理URL编码和解码）。“名称—值”（name—value）对用 &amp; 隔开。绝大部分的服务器端技术能够自动对请求主体进行解码，并为这些值的访问提供一些逻辑方式。当然，如何使用这些数据还是由服务器决定的。另一方面，POST请求在请求主体中为服务器提供了一些附加的信息。通常，当填写一个在线表单并提交它时，这些填入的数据将以POST请求的方式发送给服务器。以下就是一个典型的POST请求：POST / HTTP/1.1Host: www.baidu.comUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)Gecko/20050225 Firefox/1.0.1Content-Type: application/x-www-form-urlencodedContent-Length: 40Connection: Keep-Alivename=Professional%20Ajax&amp;publisher=Wiley从上面可以发现， POST请求和GET请求之间有一些区别。首先，请求行开始处的GET改为了POST，以表示不同的请求类型。你会发现首部Host和User-Agent仍然存在，在后面有两个新行。其中首部Content-Type说明了请求主体的内容是如何编码的。浏览器始终以application/ x-www-form- urlencoded的格式编码来传送数据，这是针对简单URL编码的MIME类型。首部Content-Length说明了请求主体的字节数。在首部Connection后是一个空行，再后面就是请求主体。与大多数浏览器的POST请求一样，这是以简单的“名称—值”对的形式给出的，其中name是Professional Ajax，publisher是Wiley。你可以以同样的格式来组织URL的查询字符串参数。下面是一些最常见的请求头： Accept：浏览器可接受的MIME类型。 Accept - Charset：浏览器可接受的字符集。 Accept - Encoding：浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间。 Accept - Language：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到。 Authorization：授权信息，通常出现在对服务器发送的WWW - Authenticate头的应答中。 Connection：表示是否需要持久连接。如果Servlet看到这里的值为“Keep - Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content - Length头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小。 Content - Length：表示请求消息正文的长度。 Cookie：这是最重要的请求头信息之一，参见后面《Cookie处理》一章中的讨论。 From：请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它。 Host：初始URL中的主机和端口。 If - Modified - Since：只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回304“Not Modified”应答。 Pragma：指定“no - cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝。 Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。 User - Agent：浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用。 UA - Pixels，UA - Color，UA - OS，UA - CPU：由某些版本的IE浏览器所发送的非标准的请求头，表示屏幕大小、颜色深度、操作系统和CPU类型。HTTP响应如下所示，HTTP响应的格式与请求的格式十分类似：&lt;status-line&gt;&lt;headers&gt;&lt;blank line&gt;[&lt;response-body&gt;]正如你所见，在响应中唯一真正的区别在于第一行中用状态信息代替了请求信息。状态行（status line）通过提供一个状态码来说明所请求的资源情况。以下就是一个HTTP响应的例子：HTTP/1.1 200 OKDate: Sat, 31 Dec 2005 23:59:59 GMTContent-Type: text/html;charset=ISO-8859-1Content-Length: 122&lt;html&gt;&lt;head&gt;&lt;title&gt;Wrox Homepage&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- body goes here --&gt;&lt;/body&gt;&lt;/html&gt;在本例中，状态行给出的HTTP状态代码是200，以及消息OK。状态行始终包含的是状态码和相应的简短消息，以避免混乱。最常用的状态码有：◆200 (OK): 找到了该资源，并且一切正常。◆304 (NOT MODIFIED): 该资源在上次请求之后没有任何修改。这通常用于浏览器的缓存机制。◆401 (UNAUTHORIZED): 客户端无权访问该资源。这通常会使得浏览器要求用户输入用户名和密码，以登录到服务器。◆403 (FORBIDDEN): 客户端未能获得授权。这通常是在401之后输入了不正确的用户名或密码。◆404 (NOT FOUND): 在指定的位置不存在所申请的资源。 js window.onload 和 jq ready 函数有何不同12345678910111213141.执行时间 window.onload必须等到页面内包括图片的所有元素加载完毕后才能执行。 $(document).ready()是DOM结构绘制完毕后就执行，不必等到加载完毕。 2.编写个数不同 window.onload不能同时编写多个，如果有多个window.onload方法，只会执行一个 $(document).ready()可以同时编写多个，并且都可以得到执行 3.简化写法 window.onload没有简化写法 $(document).ready(function()&#123;&#125;)可以简写成$(function()&#123;&#125;); jq 选中所有段落内部的div标签123456子元素选择器（&gt;），例如 $(&quot;div&gt;img&quot;) 获取div下的img子元素；遍历函数children()，例如 $(&quot;div&quot;).children(&quot;img&quot;) 同样是获取div下的img子元素。如果想要获取DIV下的不仅是子元素，而且还包括其他后代元素（孙辈、曾孙辈元素...），那么，相应的两种方法是：后代元素选择器（空格），例如 $(&quot;div img&quot;) 获取div下的所有级别的img后代元素；遍历函数find()，例如 $(&quot;div&quot;).find(&quot;img&quot;) 获取div下的所有级别的ing后代子元素。 jq 的选择器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091jQuery 的选择器可谓之强大无比，这里简单地总结一下常用的元素查找方法 $(&quot;#myELement&quot;) 选择id值等于myElement的元素，id值不能重复在文档中只能有一个id值是myElement所以得到的是唯一的元素 $(&quot;div&quot;) 选择所有的div标签元素，返回div元素数组 $(&quot;.myClass&quot;) 选择使用myClass类的css的所有元素 $(&quot;*&quot;) 选择文档中的所有的元素，可以运用多种的选择方式进行联合选择：例如$(&quot;#myELement,div,.myclass&quot;) 层叠选择器： $(&quot;form input&quot;) 选择所有的form元素中的input元素 $(&quot;#main &gt; *&quot;) 选择id值为main的所有的子元素 $(&quot;label + input&quot;) 选择所有的label元素的下一个input元素节点，经测试选择器返回的是label标签后面直接跟一个input标签的所有input标签元素 $(&quot;#prev ~ div&quot;) 同胞选择器，该选择器返回的为id为prev的标签元素的所有的属于同一个父元素的div标签 基本过滤选择器： $(&quot;tr:first&quot;) 选择所有tr元素的第一个 $(&quot;tr:last&quot;) 选择所有tr元素的最后一个 $(&quot;input:not(:checked) + span&quot;) 过滤掉：checked的选择器的所有的input元素 $(&quot;tr:even&quot;) 选择所有的tr元素的第0，2，4... ...个元素（注意：因为所选择的多个元素时为数组，所以序号是从0开始） $(&quot;tr:odd&quot;) 选择所有的tr元素的第1，3，5... ...个元素 $(&quot;td:eq(2)&quot;) 选择所有的td元素中序号为2的那个td元素 $(&quot;td:gt(4)&quot;) 选择td元素中序号大于4的所有td元素 $(&quot;td:ll(4)&quot;) 选择td元素中序号小于4的所有的td元素 $(&quot;:header&quot;) $(&quot;div:animated&quot;) 内容过滤选择器： $(&quot;div:contains(&apos;John&apos;)&quot;) 选择所有div中含有John文本的元素 $(&quot;td:empty&quot;) 选择所有的为空（也不包括文本节点）的td元素的数组 $(&quot;div:has(p)&quot;) 选择所有含有p标签的div元素 $(&quot;td:parent&quot;) 选择所有的以td为父节点的元素数组 可视化过滤选择器： $(&quot;div:hidden&quot;) 选择所有的被hidden的div元素 $(&quot;div:visible&quot;) 选择所有的可视化的div元素 属性过滤选择器： $(&quot;div[id]&quot;) 选择所有含有id属性的div元素 $(&quot;input[name=&apos;newsletter&apos;]&quot;) 选择所有的name属性等于&apos;newsletter&apos;的input元素 $(&quot;input[name!=&apos;newsletter&apos;]&quot;) 选择所有的name属性不等于&apos;newsletter&apos;的input元素 $(&quot;input[name^=&apos;news&apos;]&quot;) 选择所有的name属性以&apos;news&apos;开头的input元素 $(&quot;input[name$=&apos;news&apos;]&quot;) 选择所有的name属性以&apos;news&apos;结尾的input元素 $(&quot;input[name*=&apos;man&apos;]&quot;) 选择所有的name属性包含&apos;news&apos;的input元素 $(&quot;input[id][name$=&apos;man&apos;]&quot;) 可以使用多个属性进行联合选择，该选择器是得到所有的含有id属性并且那么属性以man结尾的元素 子元素过滤选择器： $(&quot;ul li:nth-child(2)&quot;),$(&quot;ul li:nth-child(odd)&quot;),$(&quot;ul li:nth-child(3n + 1)&quot;) $(&quot;div span:first-child&quot;) 返回所有的div元素的第一个子节点的数组 $(&quot;div span:last-child&quot;) 返回所有的div元素的最后一个节点的数组 $(&quot;div button:only-child&quot;) 返回所有的div中只有唯一一个子节点的所有子节点的数组 表单元素选择器： $(&quot;:input&quot;) 选择所有的表单输入元素，包括input, textarea, select 和 button $(&quot;:text&quot;) 选择所有的text input元素 $(&quot;:password&quot;) 选择所有的password input元素 $(&quot;:radio&quot;) 选择所有的radio input元素 $(&quot;:checkbox&quot;) 选择所有的checkbox input元素 $(&quot;:submit&quot;) 选择所有的submit input元素 $(&quot;:image&quot;) 选择所有的image input元素 $(&quot;:reset&quot;) 选择所有的reset input元素 $(&quot;:button&quot;) 选择所有的button input元素 $(&quot;:file&quot;) 选择所有的file input元素 $(&quot;:hidden&quot;) 选择所有类型为hidden的input元素或表单的隐藏域 表单元素过滤选择器： $(&quot;:enabled&quot;) 选择所有的可操作的表单元素 $(&quot;:disabled&quot;) 选择所有的不可操作的表单元素 $(&quot;:checked&quot;) 选择所有的被checked的表单元素 $(&quot;select option:selected&quot;) 选择所有的select 的子元素中被selected的元素 选取一个 name 为”S_03_22″的input text框的上一个td的text值$(”input[@ name =S_03_22]“).parent().prev().text() 名字以”S_”开始，并且不是以”_R”结尾的$(”input[@ name ^=&apos;S_&apos;]“).not(”[@ name $=&apos;_R&apos;]“) 一个名为 radio_01的radio所选的值$(”input[@ name =radio_01][@checked]“).val();]]></content>
      <categories>
        <category>Problem</category>
      </categories>
      <tags>
        <tag>Problem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP和HTTPS]]></title>
    <url>%2F2016%2F12%2F19%2Fhello-world%2F</url>
    <content type="text"><![CDATA[HTTP协议（HyperText Transfer Protocol，超文本传输协议）：是一种发布和接收 HTML页面的方法。 HTTPS（Hypertext Transfer Protocol over Secure Socket Layer）简单讲是HTTP的安全版，在HTTP下加入SSL层 SSL（Secure Sockets Layer 安全套接层）主要用于Web的安全传输协议，在传输层对网络连接进行加密，保障在Internet上数据传输的安全。 HTTP的端口号为80， HTTPS的端口号为443 URL（Uniform / Universal Resource Locator的缩写）：统一资源定位符，是用于完整地描述Internet上网页和其他资源的地址的一种标识方法。 基本格式：scheme://host[:port#]/path/…/[?query-string][#anchor] scheme：协议(例如：http, https, ftp) host：服务器的IP地址或者域名 port#：服务器的端口（如果是走协议默认端口，缺省端口80） path：访问资源的路径 query-string：参数，发送给http服务器的数据 anchor：锚（跳转到网页的指定锚点位置） e.g. ftp://192.168.0.116:8080/index https://www.baidu.com 客户端HTTP请求URL只是标识资源的位置，而HTTP是用来提交和获取资源。客户端发送一个HTTP请求到服务器的请求消息，包括以下格式： 请求行 请求头部 空行 请求方法1GET https://www.baidu.com/ HTTP/1.1 根据HTTP标准，HTTP请求可以使用多种请求方法。 HTTP 0.9：只有基本的文本 GET 功能。 HTTP 1.0：完善的请求/响应模型，并将协议补充完整，定义了三种请求方法： GET, POST 和 HEAD方法。 HTTP 1.1：在 1.0 基础上进行更新，新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。 HTTP 2.0（未普及）：请求/响应首部的定义基本没有改变，只是所有首部键必须全部小写，而且请求行要独立为 :method、:scheme、:host、:path这些键值对。 GET 请求指定的页面信息，并返回实体主体。 HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件），数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 PUT 从客户端向服务器传送的数据取代指定的文档的内容。 DELETE 请求服务器删除指定的页面。 CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 OPTIONS 允许客户端查看服务器的性能。 TRACE 回显服务器收到的请求，主要用于测试或诊断。 常见的HTTP状态码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831xx:信息100 Continue服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。101 Switching Protocols服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。2xx:成功200 OK请求成功（其后是对GET和POST请求的应答文档）201 Created请求被创建完成，同时新的资源被创建。202 Accepted供处理的请求已被接受，但是处理未完成。203 Non-authoritative Information文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝。204 No Content没有新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。205 Reset Content没有新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。206 Partial Content客户发送了一个带有Range头的GET请求，服务器完成了它。3xx:重定向300 Multiple Choices多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。301 Moved Permanently所请求的页面已经转移至新的url。302 Moved Temporarily所请求的页面已经临时转移至新的url。303 See Other所请求的页面可在别的url下被找到。304 Not Modified未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。305 Use Proxy客户请求的文档应该通过Location头所指明的代理服务器提取。306 Unused此代码被用于前一版本。目前已不再使用，但是代码依然被保留。307 Temporary Redirect被请求的页面已经临时移至新的url。4xx:客户端错误400 Bad Request服务器未能理解请求。401 Unauthorized被请求的页面需要用户名和密码。401.1登录失败。401.2服务器配置导致登录失败。401.3由于 ACL 对资源的限制而未获得授权。401.4筛选器授权失败。401.5ISAPI/CGI 应用程序授权失败。401.7访问被 Web 服务器上的 URL 授权策略拒绝。这个错误代码为 IIS 6.0 所专用。402 Payment Required此代码尚无法使用。403 Forbidden对被请求页面的访问被禁止。403.1执行访问被禁止。403.2读访问被禁止。403.3写访问被禁止。403.4要求 SSL。403.5要求 SSL 128。403.6IP 地址被拒绝。403.7要求客户端证书。403.8站点访问被拒绝。403.9用户数过多。403.10配置无效。403.11密码更改。403.12拒绝访问映射表。403.13客户端证书被吊销。403.14拒绝目录列表。403.15超出客户端访问许可。403.16客户端证书不受信任或无效。403.17客户端证书已过期或尚未生效。403.18在当前的应用程序池中不能执行所请求的 URL。这个错误代码为 IIS 6.0 所专用。403.19不能为这个应用程序池中的客户端执行 CGI。这个错误代码为 IIS 6.0 所专用。403.20Passport 登录失败。这个错误代码为 IIS 6.0 所专用。404 Not Found服务器无法找到被请求的页面。404.0没有找到文件或目录。404.1无法在所请求的端口上访问 Web 站点。404.2Web 服务扩展锁定策略阻止本请求。404.3MIME 映射策略阻止本请求。405 Method Not Allowed请求中指定的方法不被允许。406 Not Acceptable服务器生成的响应无法被客户端所接受。407 Proxy Authentication Required用户必须首先使用代理服务器进行验证，这样请求才会被处理。408 Request Timeout请求超出了服务器的等待时间。409 Conflict由于冲突，请求无法被完成。410 Gone被请求的页面不可用。411 Length Required&quot;Content-Length&quot; 未被定义。如果无此内容，服务器不会接受请求。412 Precondition Failed请求中的前提条件被服务器评估为失败。413 Request Entity Too Large由于所请求的实体的太大，服务器不会接受请求。414 Request-url Too Long由于url太长，服务器不会接受请求。当post请求被转换为带有很长的查询信息的get请求时，就会发生这种情况。415 Unsupported Media Type由于媒介类型不被支持，服务器不会接受请求。416 Requested Range Not Satisfiable服务器不能满足客户在请求中指定的Range头。417 Expectation Failed执行失败。423锁定的错误。5xx:服务器错误500 Internal Server Error请求未完成。服务器遇到不可预知的情况。500.12应用程序正忙于在 Web 服务器上重新启动。500.13Web 服务器太忙。500.15不允许直接请求 Global.asa。500.16UNC 授权凭据不正确。这个错误代码为 IIS 6.0 所专用。500.18URL 授权存储不能打开。这个错误代码为 IIS 6.0 所专用。500.100内部 ASP 错误。501 Not Implemented请求未完成。服务器不支持所请求的功能。502 Bad Gateway请求未完成。服务器从上游服务器收到一个无效的响应。502.1CGI 应用程序超时。 ·502.2CGI 应用程序出错。503 Service Unavailable请求未完成。服务器临时过载或当机。504 Gateway Timeout网关超时。505 HTTP Version Not Supported服务器不支持请求中指明的HTTP协议版本]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[data_structure]]></title>
    <url>%2F2016%2F12%2F19%2Fdata-structure%2F</url>
    <content type="text"><![CDATA[[转载]作者：LeeLom链接：http://www.jianshu.com/p/7d037c332a9d來源：简书 数据结构常见的八大排序算法（详细整理） 性能比较 交换排序快速排序算法思想 快速排序的基本思想：挖坑填数+分治法从序列当中选择一个基准数(pivot)在这里我们选择序列当中第一个数最为基准数将序列当中的所有数依次遍历，比基准数大的位于其右侧，比基准数小的位于其左侧重复步骤1.2，直到所有子集当中只有一个元素为止。用伪代码描述如下：1．i =L; j = R; 将基准数挖出形成第一个坑a[i]。2．j–由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。3．i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。4．再重复执行2，3二步，直到i==j，将基准数填入a[i]中 代码实现 123456789101112131415161718192021222324252627282930#快速排序#L：待排序的序列；start排序的开始index,end序列末尾的index#对于长度为length的序列：start = 0;end = length-1def quick_sort(L,start,end): if start &lt; end: i , j , pivot = start , end , L[start] while i &lt; j:#从右开始向左寻找第一个小于pivot的值 while (i &lt; j) and (L[j] &gt;= pivot): j = j-1#将小于pivot的值移到左边 if (i &lt; j): L[i] = L[j] i = i+1 #从左开始向右寻找第一个大于pivot的值 while (i &lt; j) and (L[i] &lt; pivot): i = i+1#将大于pivot的值移到右边 if (i &lt; j): L[j] = L[i] j = j-1#循环结束后，说明 i=j，此时左边的值全都小于pivot,右边的值全都大于pivot#pivot的位置移动正确，那么此时只需对左右两侧的序列调用此函数进一步排序即可#递归调用函数：依次对左侧序列：从0 ~ i-1//右侧序列：从i+1 ~ end L[i] = pivot#左侧序列继续排序 quick_sort(L,start,i-1)#右侧序列继续排序 quick_sort(L,i+1,end) 冒泡排序算法思想 冒泡排序思路比较简单：将序列当中的左右元素，依次比较，保证右边的元素始终大于左边的元素；（ 第一轮结束后，序列最后一个元素一定是当前序列的最大值；）对序列当中剩下的n-1个元素再次执行步骤1。对于长度为n的序列，一共需要执行n-1轮比较（利用while循环可以减少执行次数） 代码实现 12345678910111213#冒泡排序def bubble_sort(L): length = len(L)#序列长度为length，需要执行length-1轮交换 for x in range(1,length):#对于每一轮交换，都将序列当中的左右元素进行比较#每轮交换当中，由于序列最后的元素一定是最大的，因此每轮循环到序列未排序的位置即可 for i in range(0,length-x): if L[i] &gt; L[i+1]: temp = L[i] L[i] = L[i+1] L[i+1] = temp 插入排序 算法想想: 直接插入排序的核心思想就是：将数组中的所有元素依次跟前面已经排好的元素相比较，如果选择的元素比已排序的元素小，则交换，直到全部元素都比较过。因此，从上面的描述中我们可以发现，直接插入排序可以用两个循环完成： 第一层循环：遍历待比较的所有数组元素第二层循环：将本轮选择的元素(selected)与已经排好序的元素(ordered)相比较。如果：selected &gt; ordered，那么将二者交换 代码 123456789101112#直接插入排序def insert_sort(L): #遍历数组中的所有元素，其中0号索引元素默认已排序，因此从1开始 for x in range(1,len(L)): #将该元素与已排序好的前序数组依次比较，如果该元素小，则交换 #range(x-1,-1,-1):从x-1倒序循环到0 for i in range(x-1,-1,-1): #判断：如果符合条件则交换 if L[i] &gt; L[i+1]: temp = L[i+1] L[i+1] = L[i] L[i] = temp 希尔排序 算法想想: 希尔排序的算法思想：将待排序数组按照步长gap进行分组，然后将每组的元素利用直接插入排序的方法进行排序；每次将gap折半减小，循环上述操作；当gap=1时，利用直接插入，完成排序。同样的：从上面的描述中我们可以发现：希尔排序的总体实现应该由三个循环完成： 第一层循环：将gap依次折半，对序列进行分组，直到gap=1第二、三层循环：也即直接插入排序所需要的两次循环。具体描述见上。代码 代码 123456789101112131415161718#希尔排序def insert_shell(L): #初始化gap值，此处利用序列长度的一般为其赋值 gap = (int)(len(L)/2) #第一层循环：依次改变gap值对列表进行分组 while (gap &gt;= 1): #下面：利用直接插入排序的思想对分组数据进行排序 #range(gap,len(L)):从gap开始 for x in range(gap,len(L)): #range(x-gap,-1,-gap):从x-gap开始与选定元素开始倒序比较，每个比较元素之间间隔gap for i in range(x-gap,-1,-gap): #如果该组当中两个元素满足交换条件，则进行交换 if L[i] &gt; L[i+gap]: temp = L[i+gap] L[i+gap] = L[i] L[i] =temp #while循环条件折半 gap = (int)(gap/2) 选择排序简单选择排序 算法思想 简单选择排序的基本思想：比较+交换 从待排序序列中，找到关键字最小的元素；2.如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；3.从余下的 N - 1 个元素中，找出关键字最小的元素，重复(1)、(2)步，直到排序结束。因此我们可以发现，简单选择排序也是通过两层循环实现。第一层循环：依次遍历序列当中的每一个元素第二层循环：将遍历得到的当前元素依次与余下的元素进行比较，符合最小元素的条件，则交换。 代码 1234567891011121314# 简单选择排序def select_sort(L):#依次遍历序列中的每一个元素 for x in range(0,len(L)):#将当前位置的元素定义此轮循环当中的最小值 minimum = L[x]#将该元素与剩下的元素依次比较寻找最小元素 for i in range(x+1,len(L)): if L[i] &lt; minimum: temp = L[i]; L[i] = minimum; minimum = temp#将比较后得到的真正的最小值赋值给当前位置 L[x] = minimum 堆排序 堆的概念堆：本质是一种数组对象。特别重要的一点性质：任意的叶子节点小于（或大于）它所有的父节点。对此，又分为大顶堆和小顶堆，大顶堆要求节点的元素都要大于其孩子，小顶堆要求节点元素都小于其左右孩子，两者对左右孩子的大小关系不做任何要求。利用堆排序，就是基于大顶堆或者小顶堆的一种排序方法。下面，我们通过大顶堆来实现。 思想 堆排序可以按照以下步骤来完成： 首先将序列构建称为大顶堆；（这样满足了大顶堆那条性质：位于根节点的元素一定是当前序列的最大值） 2.取出当前大顶堆的根节点，将其与序列末尾元素进行交换；（此时：序列末尾的元素为已排序的最大值；由于交换了元素，当前位于根节点的堆并不一定满足大顶堆的性质） 3.对交换后的n-1个序列元素进行调整，使其满足大顶堆的性质； 4.重复2.3步骤，直至堆中只有1个元素为止 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#-------------------------堆排序--------------------------------#**********获取左右叶子节点**********def LEFT(i): return 2*i + 1def RIGHT(i): return 2*i + 2#********** 调整大顶堆 **********#L:待调整序列 length: 序列长度 i:需要调整的结点def adjust_max_heap(L,length,i):#定义一个int值保存当前序列最大值的下标 largest = i#执行循环操作：两个任务：1 寻找最大值的下标；2.最大值与父节点交换 while (1):#获得序列左右叶子节点的下标 left,right = LEFT(i),RIGHT(i)#当左叶子节点的下标小于序列长度 并且 左叶子节点的值大于父节点时，将左叶子节点的下标赋值给largest if (left &lt; length) and (L[left] &gt; L[i]): largest = left print(&apos;左叶子节点&apos;) else: largest = i#当右叶子节点的下标小于序列长度 并且 右叶子节点的值大于父节点时，将右叶子节点的下标值赋值给largest if (right &lt; length) and (L[right] &gt; L[largest]): largest = right print(&apos;右叶子节点&apos;)#如果largest不等于i 说明当前的父节点不是最大值，需要交换值 if (largest != i): temp = L[i] L[i] = L[largest] L[largest] = temp i = largest print(largest) continue else: break#********** 建立大顶堆 **********def build_max_heap(L): length = len(L) for x in range((int)((length-1)/2),-1,-1): adjust_max_heap(L,length,x)#********** 堆排序 **********def heap_sort(L):#先建立大顶堆，保证最大值位于根节点；并且父节点的值大于叶子结点 build_max_heap(L)#i：当前堆中序列的长度.初始化为序列的长度 i = len(L)#执行循环：1. 每次取出堆顶元素置于序列的最后(len-1,len-2,len-3...)# 2. 调整堆，使其继续满足大顶堆的性质，注意实时修改堆中序列的长度 while (i &gt; 0): temp = L[i-1] L[i-1] = L[0] L[0] = temp#堆中序列长度减1 i = i-1#调整大顶堆 adjust_max_heap(L,i,0) 归并排序 算法思想: 1.归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用分治法的一个典型的应用。它的基本操作是：将已有的子序列合并，达到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。 2.归并排序其实要做两件事： 分解—-将序列每次折半拆分 合并—-将划分后的序列段两两排序合并因此，归并排序实际上就是两个操作，拆分+合并 3.如何合并？L[first…mid]为第一段，L[mid+1…last]为第二段，并且两端已经有序，现在我们要将两端合成达到L[first…last]并且也有序。 首先依次从第一段与第二段中取出元素比较，将较小的元素赋值给temp[] 重复执行上一步，当某一段赋值结束，则将另一段剩下的元素赋值给temp[] 此时将temp[]中的元素复制给L[]，则得到的L[first…last]有序 4.如何分解？在这里，我们采用递归的方法，首先将待排序列分成A,B两组；然后重复对A、B序列 分组；直到分组后组内只有一个元素，此时我们认为组内所有元素有序，则分组结束。 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445# 归并排序#这是合并的函数# 将序列L[first...mid]与序列L[mid+1...last]进行合并def mergearray(L,first,mid,last,temp):#对i,j,k分别进行赋值 i,j,k = first,mid+1,0#当左右两边都有数时进行比较，取较小的数 while (i &lt;= mid) and (j &lt;= last): if L[i] &lt;= L[j]: temp[k] = L[i] i = i+1 k = k+1 else: temp[k] = L[j] j = j+1 k = k+1#如果左边序列还有数 while (i &lt;= mid): temp[k] = L[i] i = i+1 k = k+1#如果右边序列还有数 while (j &lt;= last): temp[k] = L[j] j = j+1 k = k+1#将temp当中该段有序元素赋值给L待排序列使之部分有序 for x in range(0,k): L[first+x] = temp[x]# 这是分组的函数def merge_sort(L,first,last,temp): if first &lt; last: mid = (int)((first + last) / 2)#使左边序列有序 merge_sort(L,first,mid,temp)#使右边序列有序 merge_sort(L,mid+1,last,temp)#将两个有序序列合并 mergearray(L,first,mid,last,temp)# 归并排序的函数def merge_sort_array(L):#声明一个长度为len(L)的空列表 temp = len(L)*[None]#调用归并排序 merge_sort(L,0,len(L)-1,temp) 基数排序 算法思想 1.基数排序：通过序列中各个元素的值，对排序的N个元素进行若干趟的“分配”与“收集”来实现排序。分配：我们将L[i]中的元素取出，首先确定其个位上的数字，根据该数字分配到与之序号相同的桶中收集：当序列中所有的元素都分配到对应的桶中，再按照顺序依次将桶中的元素收集形成新的一个待排序列L[ ]对新形成的序列L[]重复执行分配和收集元素中的十位、百位…直到分配完该序列中的最高位，则排序结束2.根据上述“基数排序”的展示，我们可以清楚的看到整个实现的过程 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#************************基数排序****************************#确定排序的次数#排序的顺序跟序列中最大数的位数相关def radix_sort_nums(L): maxNum = L[0]#寻找序列中的最大数 for x in L: if maxNum &lt; x: maxNum = x#确定序列中的最大元素的位数 times = 0 while (maxNum &gt; 0): maxNum = (int)(maxNum/10) times = times+1 return times#找到num从低到高第pos位的数据def get_num_pos(num,pos): return ((int)(num/(10**(pos-1))))%10#基数排序def radix_sort(L): count = 10*[None] #存放各个桶的数据统计个数 bucket = len(L)*[None] #暂时存放排序结果#从低位到高位依次执行循环 for pos in range(1,radix_sort_nums(L)+1): #置空各个桶的数据统计 for x in range(0,10): count[x] = 0 #统计当前该位(个位，十位，百位....)的元素数目 for x in range(0,len(L)): #统计各个桶将要装进去的元素个数 j = get_num_pos(int(L[x]),pos) count[j] = count[j]+1 #count[i]表示第i个桶的右边界索引 for x in range(1,10): count[x] = count[x] + count[x-1] #将数据依次装入桶中 for x in range(len(L)-1,-1,-1): #求出元素第K位的数字 j = get_num_pos(L[x],pos) #放入对应的桶中，count[j]-1是第j个桶的右边界索引 bucket[count[j]-1] = L[x] #对应桶的装入数据索引-1 count[j] = count[j]-1 # 将已分配好的桶中数据再倒出来，此时已是对应当前位数有序的表 for x in range(0,len(L)): L[x] = bucket[x]]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql_advanced]]></title>
    <url>%2F2016%2F12%2F11%2Fmysql-advanced%2F</url>
    <content type="text"><![CDATA[[TOC] 5 MySQL高级 本节课程学习MySQL数据库的高级操作，这些操作主要是由DBA或项目经理来完成，对于初级开发人员，不需要熟练操作，这部分内容作为了解，对于未来的工作是加分项账户管理：创建账户、修改密码、分配权限等存储过程：创建、删除、查看存储过程函数：创建、删除、查看函数，mysql中定义变量、选择语句、循环语句视图：完成查询语句的封装事务：保证一个业务逻辑的完整性索引：对于大数据量可以提高查询速度练习：根据性格测试的数据设计表，并编写创建表的脚本 账户管理 在生产环境下操作数据库时，绝对不可以使用root账户连接，而是创建特定的账户，授予这个账户特定的操作权限，然后连接进行操作，主要的操作就是数据的crudMySQL账户体系：根据账户所具有的权限的不同，MySQL的账户可以分为以下几种服务实例级账号：，启动了一个mysqld，即为一个数据库实例；如果某用户如root,拥有服务实例级分配的权限，那么该账号就可以删除所有的数据库、连同这些库中的表数据库级别账号：对特定数据库执行增删改查的所有操作数据表级别账号：对特定表执行增删改查等所有操作字段级别的权限：对某些表的特定字段进行操作存储程序级别的账号：对存储程序进行增删改查的操作账户的操作主要包括创建账户、删除账户、修改密码、授权权限等注意：进行账户操作时，需要使用root账户登录，这个账户拥有最高的实例级权限下面主要演示数据库级操作权限，因为通常都使用这种方式 查看所有用户 desc user\G; 创建账户并授予权限 grant 权限列表 on 数据库 to &#39;用户名&#39;@&#39;访问主机&#39; identified by &#39;密码&#39;; 授权 grant 权限名称 on 数据库 to 账户1,账户2,... with grant option; ###示例 step1：使用root登录 mysql -uroot -p回车后写密码，然后回车 step2: 用户名为tony，密码为mysql 操作python数据库的所有对象python.* 访问主机通常使用百分号%表示此账户可以使用任何ip的主机登录访问此数据库 访问主机可以设置成localhost或具体的ip，表示只允许本机或特定主机访问 grant all privileges on python.* to &#39;tony&#39;@&#39;%&#39; identified by &#39;mysql&#39;; 查看用户有哪些权限 show grant for tony step3：退出root的登录 quit 回收权限 语法如下： revoke 权限列表 on 数据库名.* from &#39;用户名&#39;@&#39;主机&#39;; 示例 step1：使用py登录后，向表classes中插入数据python3 use python; insert into classes(name) values(&#39;python3&#39;); step2：退出py quit step3：回收insert权限 revoke insert on python.* from &#39;py&#39;@&#39;%&#39;; step4：退出root quit 权限回收,inset失效 修改密码 语法1：不需登录修改密码 mysqladmin -u py -p password &#39;新密码&#39;例：mysqladmin -u py -p password &#39;123456&#39;回车后写密码，然后回车 语法2：使用root登录，修改mysql数据库的user表 update user set authentication_string=password(&#39;新密码&#39;) where user=&#39;用户名&#39;;例：update user set authentication_string=password(&#39;123&#39;) where user=&#39;py&#39;;刷新权限：flush privileges 删除账户 语法1：使用root登录 drop user &#39;用户名&#39;@&#39;主机&#39;;例：drop user &#39;py&#39;@&#39;%&#39;; 语法2：使用root登录，删除mysql数据库的user表中数据 这种方法还要删除db_mysql中的user表 delete from user where user=&#39;用户名&#39;;例：delete from user where user=&#39;py&#39;;– 操作结束之后需要刷新权限flush privileges 忘记 root 账户密码怎么办 !_! 去更改配置文件,实现免密登陆root账户,在重置密码 SQL注入攻击(数据安全)简介 SQL注入攻击是黑客对数据库进行攻击的常用手段之一。随着B/S模式应用开发的发展，使用这种模式编写应用程序的程序员也越来越多。但是由于程序员的水平及经验也参差不齐，相当大一部分程序员在编写代码的时候，没有对用户输入数据的合法性进行判断，使应用程序存在安全隐患。用户可以提交一段数据库查询代码，根据程序返回的结果，获得某些他想得知的数据，这就是所谓的SQL Injection，即SQL注入。 SQL注入攻击属于数据库安全攻击手段之一，可以通过数据库安全防护技术实现有效防护，数据库安全防护技术包括：数据库漏扫、数据库加密、数据库防火墙、数据脱敏、数据库安全审计系统。 SQL注入攻击会导致的数据库安全风险包括：刷库、拖库、撞库。 ###刷库 黑客通过入侵网站或内部运维人员多次从数据库中窃取新的用户资料和敏感信息的行为。现在的刷库方法，从开发公司开始渗透，从分站的C段开始渗透，社工目标方公司，社工目标方管理人员（google那些ID的资料）。其中用到的东西，目标方的习惯（文件夹文件名命名习惯，目标方的重要邮箱，目标方的MSN，电话，管理人员的资料，MSN，MSN密码，目标方用的安全软件等等）大杀器我见过很多了，office系列，pdf等社工邮件，一个接一个。没有大杀器的，就用chm木马，lnk后门，自解压包，不要以为这些方法很容易识破，但就是可以。我社工国内某目标，用的就是自解压包搞掂的。 拖库 拖库本来是数据库领域的术语，指从数据库中导出数据。到了黑客攻击泛滥的今天，它被用来指网站遭到入侵后，黑客窃取其数据库。 撞库 撞库是黑客通过收集互联网已泄露的用户和密码信息，生成对应的字典表，尝试批量登陆其他网站后，得到一系列可以登录的用户。很多用户在不同网站使用的是相同的帐号密码，因此黑客可以通过获取用户在A网站的账户从而尝试登录B网址，这就可以理解为撞库攻击。 提及“撞库”，就不能不说“脱库”和“洗库”。 在黑客术语里面，”脱库“是指黑客入侵有价值的网络站点，把注册用户的资料数据库全部盗走的行为，因为谐音，也经常被称作“脱库”，360的库带计划，奖励提交漏洞的白帽子，也是因此而得名。在取得大量的用户数据之后，黑客会通过一系列的技术手段和黑色产业链将有价值的用户数据变现，这通常也被称作“洗库”。最后黑客将得到的数据在其它网站上进行尝试登陆，叫做”撞库“，因为很多用户喜欢使用统一的用户名密码，”撞库“也可以使黑客收获颇丰。 函数创建 语法如下 `delimiter $$create function 函数名称(参数列表) returns 返回类型beginsql语句end $$delimiter ;` 说明：delimiter用于设置分割符，默认为分号 在“sql语句”部分编写的语句需要以分号结尾，此时回车会直接执行，所以要创建存储过程前需要指定其它符号作为分割符，此处使用//，也可以使用其它字符 示例 要求：创建函数py_trim，用于删除字符串左右两侧的空格 step1：设置分割符 delimiter $$ step2：创建函数 create function py_trim(str varchar(100)) returns varchar(100) begin declare x varchar(100); set x=ltrim(rtrim(str)); return x; end $$ step3：还原分割符 delimiter ; 查看 所有函数存储在mysql数据库下的proc表中 说明：存储过程与函数都存储在proc表中，区别在type字段，func表中无数据 查看python数据库中的函数 select name,type from mysql.proc where db=&#39;python&#39;; 调用 语法如下 select 函数名称(参数列表); 示例 要求：调用自定义函数py_trim select py_trim(&#39; a b c &#39;); 删除 说明：函数的代码无法修改，如果不能满足要求可以删除后重新创建 语法如下 drop function 函数名称; 示例 要求：删除函数py_trim drop function py_trim; 变量临时变量 声明临时变量，只能在 begin … end 体重语法如下 declare 变量名 类型 default 默认值; 例： declare x varchar(100); 设置变量值，语法如下 set 变量名=值; 例： set x=&#39;abc’; 用户变量/会话变量 只有在当前连接用户有效,其他连接用户无法访问 使用@标识声明用户变量 使用 select 来查看用户变量 定义 -- set @变量名 = 值; set @age = 20; -- 查看用户变量 select @age; -- 但是如果在 select 语句中这么使用就会有问题, 因为 &#39;=&#39; 在 select 语句中是判断是否相等 -- mysql 使用 := 在 select 语句中表示赋值 set @maxage = 0; select @maxage := max(age) from students; ####系统变量 任何一个用户都可以访问 使用 @@来标识系统变量 使用 select 来查看系统变量 -- 查询所有的系统变量 show variables; -- 查看系统变量 select @@max_connections; -- 当前用户/会话中修改系统变量 set max_connections = 1000; -- 全局修改,所有的访问用户都会生效 set global max_connection = 1000; 综合示例 要求：定义函数odd，输出1-100间的偶数 代码 ： delimiter $$ create function odd () returns varchar(300) begin declare i int default 1; declare x varchar(300) default &#39;&#39;; while i &lt;=100 do if i%2=0 then set x=concat(x,&#39; &#39;,i); end if; set i=i+1; end while; return x; end $$ delimiter ; 调用函数 select odd(); 刷新 flush privileges; 存储过程 存储过程，也翻译为存储程序，是一条或者多条SQL语句的集合，可以视为批处理，但是其作用不仅仅局限于批处理 本节主要介绍如何创建存储过程，以及如何调用、查看、修改、删除存储过程 存储过程也可以调用其他存储过程 推荐阅读：存储过程详解 创建 语法如下 delimiter // create procedure 存储过程名称(参数列表) begin sql语句 end // delimiter ; 说明：delimiter用于设置分割符，默认为分号 在“sql语句”部分编写的语句需要以分号结尾，此时回车会直接执行，所以要创建存储过程前需要指定其它符号作为分割符，此处使用//，也可以使用其它字符 示例 要求：创建查询过程，查询学生信息 code: delimiter // create procedure proc_stu() begin select * from students; end // delimiter ; 执行效果图如下: 查看 所有存储过程和函数，都存储在mysql数据库下的proc表中 查看表结构 主要字段说明： name表示名称 type表示类型，为存储过程、函数 body表示正文脚本 db表示属于的数据库 查看python数据库的所有存储过程 select name,type,body from mysql.proc where db=&#39;python&#39;; 调用 语法如下 call 存储过程(参数列表); 要求：调用存储过程proc_stu call proc_stu(); 删除 语法如下 drop procedure 存储过程名称; 要求：删除存储过程proc_stu drop procedure proc_stu; 存储过程和函数的区别 相同点 存储过程和函数都是为了可重复的执行操作数据库的 sql 语句的集合. 存储过程和函数都是一次编译,就会被缓存起来,下次使用就直接命中缓存中已经编译好的 sql, 不需要重复编译 减少网络交互,减少网络访问流量 不同点 标识符不同,函数的标识符是 function, 过程:procedure 函数中有返回值,且必须有返回值,而过程没有返回值,但是可以通过设置参数类型(in,out)来实现多个参数或者返回值 函数使用 select 调用,存储过程需要使用 call 调用 select 语句可以在存储过中调用,但是除了 select … into 之外的 select 语句都不能再函数中调用 通过 in out 参数,过程相关函数更加灵活,可以返回多个结果 在实际开发中根据个人喜好选择使用函数或者存储过程]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-primary]]></title>
    <url>%2F2016%2F12%2F10%2Fmysql-primary%2F</url>
    <content type="text"><![CDATA[[TOC] 服务器端安装 安装服务器端：在终端中输入如下命令，回车后，然后按照提示输入 sudo apt-get install mysql-server 启动服务 sudo service mysql start 停止服务 sudo service mysql stop 重启服务 sudo service mysql restart 配置 配置文件目录为/etc/mysql/mysql.cnf 主要配置项如下 bind-address表示服务器绑定的ip，默认为127.0.0.1 port表示端口，默认为3306 datadir表示数据库目录，默认为/var/lib/mysql general_log_file表示普通日志，默认为/var/log/mysql/mysql.log log_error表示错误日志，默认为/var/log/mysql/error.log 客户端图形化界面客户端navicat 进入解压的目录，运行如下命令 ./start_navicat 问题一：中文乱码 解决：打开start_navicat文件 将export LANG=&quot;en_US.UTF-8&quot;改为export LANG=&quot;zh_CN.UTF-8&quot; 问题二：试用期 解决：删除用户目录下的.navicat64目录 cd ~ rm -r .navicat64 详细连接的命令可以查看帮助文档 命令行连接 在工作中主要使用命令操作方式，要求熟练编写 打开终端，运行命令 mysql -uroot -p 回车后输入密码 或后面直接加您的密码 登录成功后，输入如下命令查看效果 查看版本：select version(); 显示当前时间：select now(); 数据库 查看所有数据库 show databases; 使用数据库 use 数据库名; 查看当前使用的数据库 select database(); 创建数据库 create database 数据库名 charset=utf8; 删除数据库 drop database python; 数据表 查看当前数据库中所有表 show tables; 查看表结构 desc 表名; 创建表 auto_increment表示自动增长 12345678CREATE TABLE table_name( column1 datatype contrai, column2 datatype, column3 datatype, ..... columnN datatype, PRIMARY KEY(one or more columns)); `– 例：创建班级表create table classes( id int unsigned auto_increment primary key not null, name varchar(10)); 例：创建学生表 create table students( id int unsigned primary key auto_increment not null, name varchar(20) default &#39;&#39;, age tinyint unsigned default 0, height decimal(5,2), gender enum(&#39;男&#39;,&#39;女&#39;,&#39;人妖&#39;,&#39;保密&#39;), cls_id int unsigned default 0 ) 修改表-添加字段 alter table students add birthday datetime; 修改表-修改字段：重命名版 table 表名 change 原名 新名 类型及约束;12例：alter table students change birthday birth datetime not null; 修改表-修改字段：不重命名版 alter table 表名 modify 列名 类型及约束; 例：alter table students modify birth date not null; 修改表-删除字段 alter table 表名 drop 列名; 例：alter table students drop birthday; 查看表的创建语句 show create table 表名; 例：show create table classes; 增删改查(curd)查询基本使用 查询所有列 select * from 表名; 例：select * from classes; 查询指定列 可以使用as为列或表指定别名 select 列1,列2,… from 表名; 例：select id,name from classes; 增加 insert into students values(0,’郭靖‘,1,&#39;蒙古&#39;,&#39;2016-1-2&#39;); insert into classes values(0,’python1’),(0,’python2’); insert into students(name) values(‘杨康’),(‘杨过’),(‘小龙女’); 修改 update students set gender=0,hometown=’古墓’ where id=5; 删除 delete from students where id=5; 备份 mysqldump –uroot –p 数据库名 &gt; python.sql; 恢复 mysql -uroot –p 新数据库名 &lt; python.sql 聚合函数 例1：查询学生总数 select count(*) from students; 例2：查询女生的编号最大值 select max(id) from students where gender=0; 例3：查询未删除的学生最小编号 select min(id) from students where isdelete=0; 例4：查询男生的编号之和 select sum(id) from students where gender=1; 例5：查询未删除女生的编号平均值 select avg(id) from students where isdelete=0 and gender=0; ##分组 例1：查询男女生总数 select gender as 性别,count(*)from studentsgroup by gender; 对比where与having where是对from后面指定的表进行数据筛选，属于对原始数据的筛选 having是对group by的结果进行筛选 分页 语法 select * from 表名limit start,count select * from studentswhere gender=1limit 0,3; 子查询(sub query)标量子查询 查询班级学生的平均身高 select * from students where age &gt; (select avg(age) from students); 列级子查询 查询还有学生在班的所有班级名字 select name from pythons where id in (select cls_id from students); 行级子查询 需求: 查找班级年龄最大,身高最高的学生 select * from students where (height,age) = (select max(height),max(age) from students); 表级子查询 查询学生与班级对应的信息 select from(select stu.,pys.name as clsname from students as stu inner join pythons as pys on stu.cls_id = pys.id)as t1; 子查询中特定关键字使用 in any|some SELECT * FROM classes WHERE id = any(SELECT DISTINCT cls_id FROM students); all SELECT * from classes WHERE id != ALL (SELECT DISTINCT cls_id FROM students WHERE cls_id BETWEEN 2 and 4); ##完整sql语句 SELECT select_expr [,select_expr,...] [ FROM tb_name [WHERE 条件判断] [GROUP BY {col_name | postion} [ASC | DESC], ...] [HAVING WHERE 条件判断] [ORDER BY {col_name|expr|postion} [ASC | DESC], ...] [ LIMIT {[offset,]rowcount | row_count OFFSET offset}] ] select distinct * from 表名 where .... group by ... having ... order by ... limit start,count]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[section]]></title>
    <url>%2F2016%2F08%2F13%2Fsection%2F</url>
    <content type="text"><![CDATA[1234取一个list或tuple的部分元素是非常常见的操作。比如，一个list如下：&gt;&gt;&gt; L = [&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;, &apos;Bob&apos;, &apos;Jack&apos;]取前3个元素，应该怎么做？ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283笨办法：&gt;&gt;&gt; [L[0], L[1], L[2]][&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;]之所以是笨办法是因为扩展一下，取前N个元素就没辙了。取前N个元素，也就是索引为0-(N-1)的元素，可以用循环：&gt;&gt;&gt; r = []&gt;&gt;&gt; n = 3&gt;&gt;&gt; for i in range(n):... r.append(L[i])... &gt;&gt;&gt; r[&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;]对这种经常取指定索引范围的操作，用循环十分繁琐，因此，Python提供了切片（Slice）操作符，能大大简化这种操作。对应上面的问题，取前3个元素，用一行代码就可以完成切片：&gt;&gt;&gt; L[0:3][&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;]L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。如果第一个索引是0，还可以省略：&gt;&gt;&gt; L[:3][&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;]也可以从索引1开始，取出2个元素出来：&gt;&gt;&gt; L[1:3][&apos;Sarah&apos;, &apos;Tracy&apos;]类似的，既然Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片，试试：&gt;&gt;&gt; L[-2:][&apos;Bob&apos;, &apos;Jack&apos;]&gt;&gt;&gt; L[-2:-1][&apos;Bob&apos;]记住倒数第一个元素的索引是-1。切片操作十分有用。我们先创建一个0-99的数列：&gt;&gt;&gt; L = range(100)&gt;&gt;&gt; L[0, 1, 2, 3, ..., 99]可以通过切片轻松取出某一段数列。比如前10个数：&gt;&gt;&gt; L[:10][0, 1, 2, 3, 4, 5, 6, 7, 8, 9]后10个数：&gt;&gt;&gt; L[-10:][90, 91, 92, 93, 94, 95, 96, 97, 98, 99]前11-20个数：&gt;&gt;&gt; L[10:20][10, 11, 12, 13, 14, 15, 16, 17, 18, 19]前10个数，每两个取一个：&gt;&gt;&gt; L[:10:2][0, 2, 4, 6, 8]所有数，每5个取一个：&gt;&gt;&gt; L[::5][0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]甚至什么都不写，只写[:]就可以原样复制一个list：&gt;&gt;&gt; L[:][0, 1, 2, 3, ..., 99]tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple：&gt;&gt;&gt; (0, 1, 2, 3, 4, 5)[:3](0, 1, 2)字符串&apos;xxx&apos;或Unicode字符串u&apos;xxx&apos;也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：&gt;&gt;&gt; &apos;ABCDEFG&apos;[:3]&apos;ABC&apos;&gt;&gt;&gt; &apos;ABCDEFG&apos;[::2]&apos;ACEG&apos;在很多编程语言中，针对字符串提供了很多各种截取函数，其实目的就是对字符串切片。Python没有针对字符串的截取函数，只需要切片一个操作就可以完成，非常简单。小结有了切片操作，很多地方循环就不再需要了。Python的切片非常灵活，一行代码就可以实现很多行循环才能完成的操作。]]></content>
      <categories>
        <category>Problem</category>
      </categories>
      <tags>
        <tag>programming</tag>
      </tags>
  </entry>
</search>
