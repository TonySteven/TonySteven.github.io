<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[apply_api_demo]]></title>
    <url>%2F2018%2F08%2F23%2Fapply-api-demo%2F</url>
    <content type="text"><![CDATA[接口调用Demo 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public Object reflow() &#123; //1.准备字段数据 String pathUrl = refluxPath; //1.1时间戳 long beginDate = new Date().getTime(); SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMddHHMMss"); String sd = sdf.format(new Date(beginDate)); String timestamp = sd; String sign = sourceZP + destZP + timestamp + secretKeyZP; //1.2SHA256机密sign String sign256 = SHA256Util.encrypt(sign); //1.3初始化json,data Map&lt;String, Object&gt; json = Maps.newHashMap(); List&lt;Map&lt;String, Object&gt;&gt; data = null; //1.4获取当前用户id String id = UserUtils.getCurUserId(); //1.5通过当前用户id查表,拿到数据 String sql = "SELECT * FROM T_IT_GRXXCJ_ZP WHERE GH = " + id; try &#123; data = DbUtil.query(sql, null); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; //1.6MaptoJSONArray JSONArray jsonData = JSONArray.fromObject(data); String sdata = jsonData.toString(); //1.7对JSONArray压缩,不用base64加密 String gzipdata = ZipCompressor.gzip(sdata); // data = HttpUtils.getParameterMap(); // String sdata = data.toString(); // byte[] bdata = gzipdata.getBytes(); // String base64data = Base64Utils.getBase64(bdata); //1.8拼接请求字段 json.put("source", sourceZP); json.put("dest", destZP); json.put("sign", sign256); json.put("timestamp", timestamp); json.put("type", typeZP); json.put("data", gzipdata); //1.9MAP2JsonElement JsonElement jedata = com.wisedu.emap.it.util.JsonUtils.toJsonElement(json); //2.发送请求 try &#123; //doPost方法是用于请求Json格式的参数,post要调价Header // httpPost.setHeader("Accept", "application/json"); // httpPost.setHeader("Content-Type", "application/json"); String response = HttpUtil.doPost(pathUrl, jedata.toString()); &#125; catch (Exception e1) &#123; // TODO Auto-generated catch block e1.printStackTrace(); &#125; return json; &#125;]]></content>
      <categories>
        <category>api</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[git 常用命令]]></title>
    <url>%2F2018%2F08%2F17%2Fgit-command%2F</url>
    <content type="text"><![CDATA[一般配置123git --version //查看git的版本信息git config --global user.name //获取当前登录的用户git config --global user.email //获取当前登录用户的邮箱 登录git1234/* 如果刚没有获取到用户配置，则只能拉取代码，不能修改 要是使用git，你要告诉git是谁在使用*/ git config --global user.name &apos;userName&apos; //设置git账户，userName为你的git账号，git config --global user.email &apos;email&apos; 增加到暂存区中12git add index.htmlgit add -A //全部添加到缓存区 增加到版本库1git commit -m &apos;备注信息&apos; 查看版本1git log --oneline 比较差异 比较的是暂存区和工作区的差异 1git diff 比较的是暂存区和历史区的差异 1git diff --cached 比较的是历史区和工作区的差异（修改） 1git diff master 删除暂存区 保证当前工作区中没有index.html 1git rm index.html --cached //使用--cached 表示只删除缓存区中的内容 回滚版本 回滚最近的一个版本 git log 1git reset --hard HEAD/commit_id 回滚到未来1git reflog 分支管理 创建分支 1git branch dev 切换分支 1git checkout dev 创建分支并切换分支 1git checkout -b dev 删除分支 1git branch -d dev 在分支上提交新的版本 1git commit -a -m &apos;dev1&apos; 合并分支 1git merge dev 分支的合并后显示log 1git log --oneline --graph --decorate 添加远程的仓库push -u-u参数 upstream 1git push origin master -u //获取最新代码 连接远程仓库 1git remote add origin 仓库的地址 查看远程仓库 1git remote -v 删除远程仓库 1git remote rm origin]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[接口Demo(Java)]]></title>
    <url>%2F2018%2F08%2F07%2Fjava-RESTful-api%2F</url>
    <content type="text"><![CDATA[结构路径 util工具类把需要用到的工具类创建在这里 controller 新建CommonController类 1234567891011121314151617181920212223242526@Controller@RequestMapping("/api")public class CommonController &#123; @Autowired public CommonService commonService; @ResponseBody @RequestMapping( value = "/GRXXCJ.do",method=RequestMethod.POST) public Object pushToMain() &#123; return this.commonService.GRXXCJ(); &#125; @ResponseBody @RequestMapping( value = "/photo.do",method=RequestMethod.POST) public Object pushToCloud() &#123; return this.commonService.photo(); &#125; @ResponseBody @RequestMapping( value = "/GRXXZP.do",method=RequestMethod.POST) public Object pushToMainZP() &#123; return this.commonService.GRXXZP(); &#125;&#125; service 新建CommonService类 12345public interface CommonService &#123; Object GRXXCJ(); Object photo(); Object GRXXZP();&#125; service.impl 默认核心代码都写在这里 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859@Servicepublic class CommonServiceImpl implements CommonService &#123; @Config(name = "refluxPath", defaultValue = "", description = "refluxPath") private static String refluxPath; @Config(name = "source", defaultValue = "", description = "source") private static String source; @Config(name = "sourceZP", defaultValue = "", description = "source") private static String dest; @Config(name = "destZP", defaultValue = "", description = "dest") private static String secretKey; @Config(name = "secretKeyZP", defaultValue = "", description = "secretKey") private static String type; @Config(name = "typeZP", defaultValue = "", description = "type") //从数据库获数据,并回流给其他接口 public Object GRXXZP() &#123; String pathUrl = refluxPath; long beginDate = new Date().getTime(); SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMddHHMMss"); String sd = sdf.format(new Date(beginDate)); String timestamp = sd; String sign = sourceZP + destZP + secretKeyZP; String sign256 = SHA256Util.encrypt(sign); JSONObject json = new JSONObject(); List&lt;Map&lt;String, Object&gt;&gt; data = null; String sql = "SELECT * FROM T_IT_GRXXCJ_ZP"; try &#123; data = DbUtil.query(sql, null); System.out.println("data======================" + data); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; // data = HttpUtils.getParameterMap(); String sdata = data.toString(); byte[] bdata = sdata.getBytes(); try &#123; String base64data = Base64Utils.encode(bdata); String gzipdata = ZipCompressor.gzip(base64data); json.put("source", sourceZP); json.put("dest", destZP); json.put("sign", sign256); json.put("timestamp", timestamp); json.put("type", typeZP); json.put("data", gzipdata); JsonElement jedata = com.wisedu.emap.it.util.JsonUtils.toJsonElement(json); HttpUtils.post(pathUrl, null, jedata); // HttpRequestUtil.doHttpPost(json.toString(),pathUrl); // JSONObject json_to_data = json.getJSONObject("data"); &#125; catch (Exception e1) &#123; // TODO Auto-generated catch block e1.printStackTrace(); &#125; return json; &#125;&#125;]]></content>
      <categories>
        <category>api</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[幂等性浅谈]]></title>
    <url>%2F2018%2F08%2F07%2FIdempotency%2F</url>
    <content type="text"><![CDATA[概述 幂等性原本是数学上的概念，即使公式：f(x)=f(f(x)) 能够成立的数学性质。用在编程领域，则意为对同一个系统，使用同样的条件，一次请求和重复的多次请求对系统资源的影响是一致的 幂等性是分布式系统设计中十分重要的概念，具有这一性质的接口在设计时总是秉持这样的一种理念：调用接口发生异常并且重复尝试时，总是会造成系统所无法承受的损失，所以必须阻止这种现象的发生 幂等有两个维度：一是空间维度上的幂等，即幂等对象的范围，是个人还是机构，是某一次交易还是某种类型的交易…二是时间维度上的幂等，即幂等的保证时间，是几秒、几分钟还是永久性的… 不同的需求，会有不一样的解决方案，难度和成本也不一样 幂等性适用领域试想这样的一种场景：在电商平台上支付后，因为网络原因导致系统提示你支付失败，于是你又重新付款了一次，等完成后检查网银发现被系统扣了两次款，这是一种什么样的体验？ 造成上述问题的原因可能有很多，比如第一次付款时实际支付成功，但是信息返回时网络中断导致系统误判；又比如第一次付款的确失败了，但第二次付款时发生意外，导致支付请求被重复发送等等。在一次支付的过程中，每个环节都有可能会发生问题，我们要如何规避这类问题引发的分险？ 幂等性是解决这类问题的方案之一，所以在电商，银行，互联网金融等对数据准确性要求很高的领域中，这一特性具有十分重要的地位。 幂等的常用思路1. MVCC多版本并发控制，乐观锁的一种实现，在数据更新时需要去比较持有数据的版本号，版本号不一致的操作无法成功。例如博客点赞次数自动+1的接口： 1public boolean addCount(Long id, Long version); 1update blogTable set count= count+1,version=version+1 where id=321 and version=123 2. 去重表利用数据库表单的特性来实现幂等，常用的一个思路是在表上构建唯一性索引，保证某一类数据一旦执行完毕，后续同样的请求再也无法成功写入。 例子还是上述的博客点赞问题，要想防止一个人重复点赞，可以设计一张表，将博客id与用户id绑定建立唯一索引，每当用户点赞时就往表中写入一条数据，这样重复点赞的数据就无法写入。 3. TOKEN机制这种机制就比较重要了，适用范围较广，有多种不同的实现方式。其核心思想是为每一次操作生成一个唯一性的凭证，也就是token。一个token在操作的每一个阶段只有一次执行权，一旦执行成功则保存执行结果。对重复的请求，返回同一个结果。 以电商平台为例子，电商平台上的订单id就是最适合的token。当用户下单时，会经历多个环节，比如生成订单，减库存，减优惠券等等。 每一个环节执行时都先检测一下该订单id是否已经执行过这一步骤，对未执行的请求，执行操作并缓存结果，而对已经执行过的id，则直接返回之前的执行结果，不做任何操作。这样可以在最大程度上避免操作的重复执行问题，缓存起来的执行结果也能用于事务的控制等。 总结幂等性是分布式领域的一把利刃，每一个有志与分布式领域的程序员都应该熟悉它的设计思想]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[eclipse操作指南]]></title>
    <url>%2F2018%2F08%2F07%2Feclipse-keymap%2F</url>
    <content type="text"><![CDATA[一、基本操作入门（1）内容提示：Alt + /（2）快速修复：Ctrl + 1（3）导包：Ctrl + shift + O（4）代码快速排版：Ctrl + Shift + F（5）代码位置调换：Alt+上下键（6）添加/除去单行注释 Ctrl+/（7）添加/除去多行注释 Ctrl+Shift+/和Ctrl+Shift+\（8）打印语句快速提示：Syso+Alt+/ （同理foreach,while,if,for等）（9）大小写转换：ctrl + shift +x ：选中部分转换为大写，+y转换为小写（10）快速定位源代码：ctrl + 鼠标放在需要定位的方法/类 （11）ctrl+shift+t：全Workspace范围查找类或接口（Type），这在类很多的时候或是希望查找一些开源项目的类时尤为有用（12）删除选中行：ctrl+d（13）Ctrl+L 定位在某行 (对于程序超过100的人就有福音了)（14）Ctrl+M 最大化当前的Edit或View (再按则反之)（15）F4 显示类图（16）Ctrl + Alt + ↓(↑) : 向下(上)复制本行（17）ctrl + O：快速定位类中的成员位置，这个在大类中定位尤为有用，当然这并不代表鼓励编写大类（18）ctrl + F：弹出查找框（19）ctrl + K/ctrl + shift + K：向后查找/向前查找（20）ctrl + J：更快速的增量查找，当你按完了以后会发现啥也没发生，不要担心，你只管输入想查找的字符就行了，它们会显示在Eclipse底部的状态条上，并且会根据输入进行快速增量查找（21）ctrl + I（i）：自动调整好当前缩进（22）Ctrl+Shift+R：全Workspace范围查找文件（Resource），这在文件很多的时候尤为有用（23）Ctrl+T：查看一个类的层级结构，在阅读代码时，查找当前类的子类时特别有用。在方法上使用时则是显示下级复写过此方法的类有哪些（24）Shift+Enter | Ctrl+Shift+Enter前者在当前行下面加一行同时光标移动到下行行首，比直接按Enter键的好处是可以在当前行任意位置按而不会将后面的字符切换到下一行去；后者则是在当前行上面加一行 二、eclipse操作进阶当前文件内操作当前文件内部的操作显然是我们平时最多的操作，因此这个也是做到全键盘编码的关键，以下按照定位、选中、其他三个分类来分别介绍 光标定位快捷键 Ctrl+Left/Right向左或向右跳跃一个单词，这是解决横向光标定位速度问题最主要的快捷键！（特别对于喜欢写超过80个字符一行代码的人来说）需要配合使用同样用于同行光标定位的Home/End键 Ctrl+Home/End 到达文件底部，没啥好说的，大众型的快捷键，几乎所有的Windows下文本编辑器都支持这个键。解决光标纵向定位问题 Ctrl+Shift+Up/Down 向上或是向下跳一个方法，解决光标纵向定位速度问题的主要快捷键！需要配合Ctrl+O来使用以快速跨越多个方法定位。（这个键在xml文件编辑中也能用） Ctrl+Up/Down 当希望光标不移动而屏幕移动时使用，以调整视野 Ctrl+Shift+P 跳转到和当前括号（大中小括号均可）匹配的另一半括号处，用于快速找到“另一半”^_^选中快捷键选中操作也是我们鼠标最常用的操作之一，下面的简单几个快捷键可以满足选中的需求而无需鼠标 Ctrl+Shift+Left/Right 前面刚好说到Ctrl+Left/Right是跳跃一个单词，那么这个快捷键自然就是选中一个单词了，这个是最重要的选中快捷键之一！另一个是Alt+Shift+Up/Left/Right/Down Alt+Shift+Up/Left/Right/Down 很多人喜欢用鼠标双击的功能来选中“某一小段”内容。但是当全部用了键盘之后怎么办呢？这里Alt+Shift+Up和双击功能差不多，但更加强大！你可以在一个方法中的某一行开始尝试开始按Alt+Shift+Up，慢慢体会它的规则吧！相应的Alt+Shift+Down就是将刚刚的选中步骤一步步后退。至于Left和Right可以自己尝试体会 Shift+Up/Down 很多人选中一段代码时总是喜欢从一行头复制到一行尾，这样看起来更整齐而且可以保证选中后粘贴的格式，但Eclipse里其实有很多配合快捷键都不需要我们选中的那么完整，例如，希望将当前行和当前行+1两行向前缩进，只需在当前行任意位置按Shift+Down，再按Tab即可，如果先跳转到行首速度就慢了 其他文件内快捷键 Ctrl+Backspace/Delete 这是一个编辑型的快捷键，有时候我们希望删掉同行的一大段内容（例如一个10个字母组成的单词的变量名），那么要么按Ctrl+Shift+Left/Right选中，然后再按Backspace/Delete键，有没有快捷的方式呢？当然了，按Ctrl+Backspace/Delete就是向前或是向后删除一个单词 F2 我们经常喜欢使用鼠标悬停在有编译错误或是警告的时候查看警告内容，或是查看一个类或方法的Javadoc，那么没有鼠标了之后这个问题如何解决呢？答案就是F2 文件间跳转 Ctrl+PageUp/PageDown 最容易理解的文件间切换快捷键，当打开多个文件时，它可以在相邻文件窗口间进行切换 Ctrl+F6 最有用的文件窗口间切换快捷键！在最后两个切换到的文件间切换，喜欢用Alt+Tab的朋友可以很容易理解。非常好用，可惜被Eclipse赋予了一个这么难按的位置（在IDEA里这个键是Ctrl+Tab） Alt+Left/Right 按照文件打开历史进行窗口切换，这个也是非常重要的快捷键，它的好处有两个：1. 它定位的是位置而不是文件，因此它可以在同一个文件中进行定位切换，这点在阅读代码时尤为有用！例如F3键跳转后在同一个文件中，希望回到刚刚跳过来的位置 2.即使历史上的文件窗口已经被关闭了它仍然会打开！（PS. 这个快捷键在浏览器里也是历史切换的快捷键） Ctrl+E 当文件打开过多以至于顶部tab显示不完整时，我们经常会点击最右侧的下拉按钮来选中未被显示在顶部tab中但是已经打开的文件。现在不需要鼠标，按Ctrl+E即可打开，然后可以输入期望的名称进行过滤，如果前面的几个切换快捷键太难记，只记这个也可以 F3 上篇中介绍过，用于模拟Ctrl+鼠标点击动作 ctrl+Shift+T/R 在上一篇中已经说过，用于查找类型和资源的两个快捷键，这两个快捷键也是出场率极高的两个快捷键 Ctrl+Q 回到最后一次编辑（改动）的位置，如果记得住自己最后改的哪里也可以考虑这个快捷键*View之间跳转 Ctrl+F7 这个快捷键与Ctrl+F6差不多，只是来回切换于不同的View之间（也是Alt+Tab的style）。举个例子：有很多同学不喜欢Ctrl+Shift+T/R方式来查找类或是文件，更喜欢在左侧的Project Explorer中选择文件，那么从编辑框切换到explorer框的动作就可以使用这个快捷键来实现（目录树上操作左右键用于收起/展开树形结构）。这个键也同样可以用于切换到Console或是JUnit Result的View中 Alt+Shift+W 从某个视图中显示当前文件，可以按着尝试下，这在希望查看当前编辑文件的所在位置时特别有用 Alt+Shift+Q, ? 打开某个视图，这个可以从顶部菜单的Window - Show View中查到 三、Source系列，用于生成代码以下所有快捷键基本都以按Alt+Shift+S起头，之后在配合一个按键来触发。有一些Source相关的快捷键已经在前面几篇介绍过了 Alt+Shift+S, R 这个几乎是在传统J2EE开发中用的最多的键了。用于为当前类的成员变量生成Getter/Setter，进入后焦点停留在属性选择框中，可以按上下键选择属性，空格键勾选，左右键展开，按回车确认（等同于点击OK按钮）。如果希望全部生成，可以按Alt+A，如果仅生成所有属性的Setter（例如开发Struts2的Action）则按 Alt+L，如果仅生成Getter则按Alt+G。如果按过以上三个快捷键后，焦点会停留在按钮上，此时按回车键会无效（变成了触发按钮点击事件），此时按几次Shift+Tab让焦点回到属性勾选框中，再按回车即可。 Alt+Shift+S, V 用于复写父类方法，自动生成复写父类的空方法。选择框操作方法同上。 Alt+Shift+S, S 和Alt+Shift+S, H 分别用于根据成员变量生成toString()方法和hashCode()/equals()方法。其中toString方法是以”classname[prop1=value1, prop2=value2, …]”格式输出当前类，而hashCode和equals则是按照EffiectiveJava中所描述的方式生成的，具体大家可以自己生成一个看看就明白了（不过生成的hashCode/equals方法的代码中单行if后木有大括号，因此有代码洁癖的同学，比如我，可能得手工再改改，呵呵） Alt+Shift+S, O 和Alt+Shift+S, C 前者用于根据成员变量生成构造器。也是出场率非常高的一个快捷键。不过如果在使用类似hibernate等ORM的项目中可能会用的相对较少。后者根据父类构造器的状况来生成一个构造器。相对用的较少一点 Alt+Shift+S, M 非常有意思的一个快捷键，用于生成成员变量的代理方法。在希望使用包装器模式或是代理模式时特别有用（不用自己去写一堆重复的代码了） Alt+Shift+S, U 清理代码！可以帮你优化很多当前类的代码内容（当然不是逻辑上的），比如神马去掉不必要的cast啦，神马补上@Override啦，去掉没用的import啦，之流之流。你还可以自己创建一个profile来决定哪些需要哪些不需要。当然，如果平时写代码比较精益求精的话，这个东东是派不上用场的啦 四、Refactor系列，用于重构代码相关言归正传，以下是一些可能常用的重构快捷键，Refactor里面还有很多其他的东西，但个人觉得除了以下几个之外平时都会用得很少，（有一些可能是有更好的之前介绍过的替代方案，例如Alt+Shift+L生成本地变量就不如Ctrl+1来得方便）： Alt+Shift+R 和Ctrl+2, R 两个都是改名键，不同的是，前者会将整个项目中所有用到的地方都给改了，而后者仅仅只会变更文件内部的所有引用。例如，有一个public String getName()方法，在getName上按Alt+Shift+R，输入getUsername回车，那么整个workspace里所有引用了这个getName方法的地方全部会变成getUsername，那Ctrl+2, R又有啥用呢？相比Alt+Shift+R最主要的好处就是速度快，因为不用扫描整个workspace，一般在修改一些local变量或是新的类中的名称时（还木有外部引用）来使用。所以如果你对自己的机器速度足够有信心，可以总是使用Alt+Shift+R。 Alt+Shift+M 抽取一个方法，是重构时常用的一个快捷键。使用方法是，先选中一段代码，然后按Alt+Shift+M，这个时候会弹出一个对话框，问你是否需要将这段代码抽取为一个方法，其中所有的入口参数出口参数都会自动帮你计算好。如果确认OK则自动生成好代码。不过说实话觉得这个功能不太实用，因为我老是会纠结于入口参数顺序等问题，最后还得自己改，呵呵 Alt+Shift+T, E 和 Alt+Shift+T,T 前者生成一个接口并使得当前类实现它，接口中会同时生成当前类中指定的方法声明，当前类Override它们。后者则是生成一个父类并使得当前类继承它，同时可以将指定当前类的方法提升到父类中去。 Alt+Shift+T, U 和Alt+Shift+T, D 前者将一个方法抽取到父类中，后者将一个方法放到子类中。 五、其他 Ctrl+2, L :灰常有用的一个快捷键！用于生成变量的声明。大致使用方式是这样的，例如我们希望创建一个List，那么我们只需要输入 new ArrayList() ，然后按Ctrl+2, L ，系统会自动生成左边的 ArrayList arrayList = ，并且此时光标为选中arrayList变量名状态，此时可以直接输入变量名，然后按tab键切换到声明类型，会列出可能的声明类型（实现类的父类们），按下选中List回车，最终结果就成了 List mylist = new ArrayList(); 。要用好这个快捷键需要我们改掉一个之前的习惯，就是之前总是先写声明，而现在需要先写实现，忘记声明这回事儿 Alt+Shift+Z :生成可以包装用的一些代码，使用方法是先选中一堆代码，然后按Alt+Shift+Z，可以看到有神马try/catch啊，do啊，if啊之类的。使用之后会把之前选择的那些代码包到各自的块里去（例如try/cache之间的block） Alt+Shift+J :生成当前类、方法的javadoc 六、模板 除了以上之外，还有个灰常有用的代码生成武器，那就是模板了。先做个实验：在任意一个方法里，先输入syso，然后按Alt+/然后换一行，重新输入if，然后按Alt+/，选择第一个按回车，这就是模板，它可以为我们节省大量的重复劳动，以加快编码速度，熟练的掌握模板可以大大提升平时的编码速度 这里有一点要注意的是，模板和普通提示一样，都会一起显示在Alt+/之后的下拉列表中，因此有时候模板很可能不在第一个，可能前面全是一些类或变量名提示。例如输入f然后按Alt+/第一个是finalize而非for，那么如何快速选中模板呢？答案是再多按一次Alt+/就行了，按两次Alt+/下拉列表会切换到完全只有模板的模式下。 从哪里获知有些什么可选模板呢？在Eclipse顶部菜单中选择 Window - Show View - Templates 可以将模板的View显示在Eclipse主界面上。而配置的地方则在Window - Preferences - Java - Editor - Templates。 如果懒得自己看的话，我这里列举几个我常用的：try, if, for, fore(foreach), new, sysout, main, Test(JUnit4+),true(javadoc), false(javadoc), null(javadoc)。 七、断点调试中的快捷键 F5 Step Into 单步进入 F6 Step Over 单步执行跳过 F7 Step Return 单步跳出 八、eclipse常见配置 显示行号：Window-&gt;Preferences&gt;General-&gt;Editors-&gt;TextEditors-&gt;勾选show line numbers（或者直接在编辑栏左侧边框上右键选择show line numbers。 增强Eclipse、MyEclipse的代码自动提示功能 Windows→Preferences→Java→Editor→ContentAssist AutoActivation Delay默认值为200（单位是毫秒）也就是说在打“.”之后停留200毫秒才能出现智能感知的提示。那么将它修改为20之后提示速度明显上升。 原理：“Auto Activationtriggers for java”这个选项就是指触发代码提示的的选项，把“.” 改成“.abcdefghijklmnopqrstuvwxyz(,”的意思，就是指遇到26个字母和.，（这些符号就触发代码提示功能了。（具体后面有 说，放心）增强Eclipse，MyEclipse 的代码提示功能，具体怎么样来配置？下面开始说步骤 (1). 打开Eclipse，然后“window”→“Preferences” (2). 选择“java”，展开，“Editor”，选择“ContentAssist”。 (3). 选择“Content Assist”，然后看到右边，右边的“Auto-Activation”下面的“AutoActivation triggers for java”这个选项。其实就是指触发代码提示的就是“.”这个符号. (4). “Auto Activation triggers for java”这个选项，在“.”后加abc字母，方便后面的查找 修改。然后“apply”，点击“OK”。 (5). 然后，“File”→“Export”，在弹出的窗口中选择“Perferences”，点击“下一步”。 (6). 选择导出文件路径，本人导出到桌面，输入“test”作为文件名，点击“保存”。 (7). 在桌面找到刚在保存的文件“test.epf”,右键选择“用记事本打开”。 (8). 可以看到很多配置Eclipse的信息 (9). 按“ctrl + F”快捷键，输入“.abc”，点击“查找下一个”。 (10). 查找到“.abc”的配置信息. (11). 把“.abc”改成“.abcdefghijklmnopqrstuvwxyz(,”，保存，关闭“test.epf”。 (12). 回到MyEclipse 6.0.1界面，“File”→“Import”，在弹出的窗口中选择“Perferences”，点击 “下一步”，选择刚在已经修改的“test.epf”文件，点击“打开”，点击“Finish”。该步骤和上面 的导出步骤类似。 (13). 最后当然是进行代码测试了。随便新建一个工程，新建一个类。 总结：“Auto Activation triggers for java”这个选项就是指触发代码提示的的选项，把“.”改成“.abcdefghijklmnopqrstuvwxyz(,”的意思，就是指遇到26个字母和.，（这些符号就触发代码提示功能了。顺便说一下，修改类名，接口名等以不同颜色高亮的，可以这样配置在“java”→“enditor”→ “syntac”，右边展开“java”→“classes”，勾上“Enable”这个选项，选择自己喜欢的颜色即可。当然还有其他相关的颜色配置。具体就不说啦。其实，在“Preferences”这个东西，有很多可以配置的东西，使得MyEclipse 优化的，具体的就要各个人根据自己个人喜好去配置了。]]></content>
      <categories>
        <category>IDE</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[oracle数据库锁表解决办法]]></title>
    <url>%2F2018%2F08%2F07%2Foracle_solution_to_unlock_tab%2F</url>
    <content type="text"><![CDATA[当多人同时操作oracle数据库的同一张表的时候，经常会造成锁表现象，这时需要手动进行解锁 首先：先看下那些表被锁住，程序如下 123456789//1select b.owner,b.object_name,a.session_id,a.locked_modefrom v$locked_object a,dba_objects bwhere b.object_id = a.object_id;//2 select b.username,b.sid,b.serial#,logon_timefrom v$locked_object a,v$session bwhere a.session_id = b.sid order by b.logon_time; 杀死进程中的会话 1alter system kill session 'sid,serial#'; 举例： 123alter system kill session '29,5497';//其中29指第一条sql中sid列内容，5497指第二条sql中serial#列内容]]></content>
      <categories>
        <category>problems</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ueditor设置默认输入的字体、行间距]]></title>
    <url>%2F2018%2F08%2F03%2Fueditor_set_fontsize%2F</url>
    <content type="text"><![CDATA[问题分析 项目需求，要求在Ueditor中，不勾选任何样式编辑的情况下，存入数据库中的是微软雅黑的字体，目前问题是存入数据库的只有p标签 后来尝试改P标签的样式改成 这么设置确实在ue的编辑页面，显示成为默认的字体了，但是提交后台保存时，并没有将改样式保存至数据库中，经过对比发现，点击编辑区域更改后的字体样式，是直接在\&lt;p>中标注标签,而我们设置好的字体，是写在样式表中的（如下图2），ue在提交后台保存时，只提交了\&lt;p>标签样式信息被过滤。 ###解决方法 在初始化ueditor时,手动设置即可 var editor12345editor.ready(function()&#123; editor.execCommand('fontfamily','微软雅黑'); //字体 editor.execCommand('lineheight', 1.5); //行间距 editor.execCommand('fontsize', '16px'); //字号&#125;);]]></content>
      <categories>
        <category>problems</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[翻墙教程]]></title>
    <url>%2F2018%2F07%2F20%2Ffree-ss%2F</url>
    <content type="text"><![CDATA[下载shadowsocks 获取SS服务器账号密码 步骤1根据版本下载Shadowsocks以MAC OS为例 步骤2简单免费方法打开网站http://free-ss.cf 费事免费一年方法自己搭建SS服务器(Google Cloud Platform) 步骤3发现新世界]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[问题总结]]></title>
    <url>%2F2017%2F11%2F27%2Fresumeexec%2F</url>
    <content type="text"><![CDATA[删除列表重复元素123def deleteDuplicatedElementFromList3(listA): #return list(set(listA)) return sorted(set(listA), key = listA.index) python中拷贝一个对象 如果需要拷贝对象，需要使用标准库中的copy模块 12import copynew_list = copy.copy(existing_list) python单例模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138 #coding=utf-8 print '----------------------方法1--------------------------' #方法1,实现__new__方法 #并在将一个类的实例绑定到类变量_instance上, #如果cls._instance为None说明该类还没有实例化过,实例化该类,并返回 #如果cls._instance不为None,直接返回cls._instance class Singleton(object): def __new__(cls, *args, **kw): if not hasattr(cls, '_instance'): orig = super(Singleton, cls) cls._instance = orig.__new__(cls, *args, **kw) return cls._instance class MyClass(Singleton): a = 1 one = MyClass() two = MyClass() two.a = 3 print one.a #3 #one和two完全相同,可以用id(), ==, is检测 print id(one) #29097904 print id(two) #29097904 print one == two #True print one is two #True print '----------------------方法2--------------------------' #方法2,共享属性;所谓单例就是所有引用(实例、对象)拥有相同的状态(属性)和行为(方法) #同一个类的所有实例天然拥有相同的行为(方法), #只需要保证同一个类的所有实例具有相同的状态(属性)即可 #所有实例共享属性的最简单最直接的方法就是__dict__属性指向(引用)同一个字典(dict) #可参看:http://code.activestate.com/recipes/66531/ class Borg(object): _state = &#123;&#125; def __new__(cls, *args, **kw): ob = super(Borg, cls).__new__(cls, *args, **kw) ob.__dict__ = cls._state return ob class MyClass2(Borg): a = 1 one = MyClass2() two = MyClass2() #one和two是两个不同的对象,id, ==, is对比结果可看出 two.a = 3 print one.a #3 print id(one) #28873680 print id(two) #28873712 print one == two #False print one is two #False #但是one和two具有相同的（同一个__dict__属性）,见: print id(one.__dict__) #30104000 print id(two.__dict__) #30104000 print '----------------------方法3--------------------------' #方法3:本质上是方法1的升级（或者说高级）版 #使用__metaclass__（元类）的高级python用法 class Singleton2(type): def __init__(cls, name, bases, dict): super(Singleton2, cls).__init__(name, bases, dict) cls._instance = None def __call__(cls, *args, **kw): if cls._instance is None: cls._instance = super(Singleton2, cls).__call__(*args, **kw) return cls._instance class MyClass3(object): __metaclass__ = Singleton2 one = MyClass3() two = MyClass3() two.a = 3 print one.a #3 print id(one) #31495472 print id(two) #31495472 print one == two #True print one is two #True print '----------------------方法4--------------------------' #方法4:也是方法1的升级（高级）版本, #使用装饰器(decorator), #这是一种更pythonic,更elegant的方法, #单例类本身根本不知道自己是单例的,因为他本身(自己的代码)并不是单例的 def singleton(cls, *args, **kw): instances = &#123;&#125; def _singleton(): if cls not in instances: instances[cls] = cls(*args, **kw) return instances[cls] return _singleton @singleton class MyClass4(object): a = 1 def __init__(self, x=0): self.x = x one = MyClass4() two = MyClass4() two.a = 3 print one.a #3 print id(one) #29660784 print id(two) #29660784 print one == two #True print one is two #True one.x = 1 print one.x #1 print two.x #1 lambda函数 lambda存在意义就是对简单函数的简洁表示 1234561.g = lambda x:x+1or lambda x:x+1(1)meansdef g(x): return x+1 python实现一个stack1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Stack(object): # 初始化栈为空列表 def __init__(self): self.items = [] # 判断栈是否为空，返回布尔值 def is_empty(self): return self.items == [] # 返回栈顶元素 def peek(self): return self.items[len(self.items) - 1] # 返回栈的大小 def size(self): return len(self.items) # 把新的元素堆进栈里面（程序员喜欢把这个过程叫做压栈，入栈，进栈……） def push(self, item): self.items.append(item) # 把栈顶元素丢出去（程序员喜欢把这个过程叫做出栈……） def pop(self, item): return self.items.pop()if __name__ == __main__: # 初始化一个栈对象 my_stack = Stack() # 把'h'丢进栈里 my_stack.push('h') # 把'a'丢进栈里 my_stack.push('a') # 看一下栈的大小（有几个元素） print my_stack.size() # 打印栈顶元素 print my_stack.peek() # 把栈顶元素丢出去，并打印出来 print my_stack.pop() # 再看一下栈顶元素是谁 print my_stack.peek() # 这个时候栈的大小是多少？ print my_stack.size() # 再丢一个栈顶元素 print my_stack.pop() # 看一下栈的大小 print my_stack.size # 栈是不是空了？ print my_stack.is_empty() # 哇~真好吃~ print 'Yummy~' str对象方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//1. 首字母大写capitalize()s.capitalize() 返回s的一份拷贝，并不改变s。如果 s 的首字符是一个字母，则拷贝的首字母将其改成大写，其余所有字母转成小写。例如：&gt;&gt;&gt; 'this is a test string.'.capitalize()'This is a test string.'&gt;&gt;&gt; '_this is a test string.'.capitalize()# 开头不是字母，不变'_this is a test string.'&gt;&gt;&gt; 'this is A test string.'.capitalize()# 除开头外的其他位置上的字母全转成小写'This is a test string.' 2. 对齐方式（1）左右对齐 ljust()、rjust()s.ljust(width[, fillchar])s.rjust(width[, fillchar]) 返回一个长度为 max(len(s), width) 的字符串，如果 width &gt; len(s)，则左/右对齐，并在另一端填充 fillchar例如：&gt;&gt;&gt; '1234'.rjust(8, '#')'####1234'&gt;&gt;&gt; '1234'.ljust(8, '#')'1234####'&gt;&gt;&gt; '1234'.ljust(2, '#')'1234'（2）居中 center()s.center(n, fillchar=' ') 返回一个新的字符串，新字符串的长度为 max(len(s), n)，当 n &gt; len(s)时，使用参数 fillchar （默认为空格）填充新字符串中其余的位置，并将 s 置于新字符串的中部。例如：&gt;&gt;&gt; 'test'.center(3)'test'&gt;&gt;&gt; 'test'.center(5)' test'&gt;&gt;&gt; 'test'.center(6, '#')'#test#'&gt;&gt;&gt; 'test'.center(7, '~')'~~test~' 可见当左右无法均衡填充时，优先填充左侧。 3. 计数count()s.count(sub, start=0, end=sys.maxint) 统计 s[start:end] 中，子串 sub 出现的次数。 http请求头,常见的响应状态码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778HTTP由两部分组成：请求和响应。当你在Web浏览器中输入一个URL时，浏览器将根据你的要求创建并发送请求，该请求包含所输入的URL以及一些与浏览器本身相关的信息。当服务器收到这个请求时将返回一个响应，该响应包括与该请求相关的信息以及位于指定URL（如果有的话）的数据。直到浏览器解析该响应并显示出网页（或其他资源）为止。HTTP请求HTTP请求的格式如下所示：&lt;request-line&gt;&lt;headers&gt;&lt;blank line&gt;[&lt;request-body&gt;]在HTTP请求中，第一行必须是一个请求行（request line），用来说明请求类型、要访问的资源以及使用的HTTP版本。紧接着是一个首部（header）小节，用来说明服务器要使用的附加信息。在首部之后是一个空行，再此之后可以添加任意的其他数据[称之为主体（body）]。在HTTP中，定义了多种请求类型，通常我们关心的只有GET请求和POST请求。只要在Web浏览器上输入一个URL，浏览器就将基于该URL向服务器发送一个GET请求，以告诉服务器获取并返回什么资源。对于www.baidu.com的GET请求如下所示：GET / HTTP/1.1Host: www.baidu.comUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)Gecko/20050225 Firefox/1.0.1Connection: Keep-Alive请求行的第一部分说明了该请求是GET请求。该行的第二部分是一个斜杠（/），用来说明请求的是该域名的根目录。该行的最后一部分说明使用的是HTTP 1.1版本（另一个可选项是1.0）。那么请求发到哪里去呢？这就是第二行的内容。第2行是请求的第一个首部，HOST。首部HOST将指出请求的目的地。结合HOST和上一行中的斜杠（/），可以通知服务器请求的是www.baidu.com/（HTTP 1.1才需要使用首部HOST，而原来的1.0版本则不需要使用）。第三行中包含的是首部User-Agent，服务器端和客户端脚本都能够访问它，它是浏览器类型检测逻辑的重要基础。该信息由你使用的浏览器来定义（在本例中是Firefox 1.0.1），并且在每个请求中将自动发送。最后一行是首部Connection，通常将浏览器操作设置为Keep-Alive（当然也可以设置为其他值）。注意，在最后一个首部之后有一个空行。即使不存在请求主体，这个空行也是必需的。要发送GET请求的参数，则必须将这些额外的信息附在URL本身的后面。其格式类似于：URL ? name1=value1&amp;name2=value2&amp;..&amp;nameN=valueN该信息称之为查询字符串（query string），它将会复制在HTTP请求的请求行中，如下所示：GET /books/?name=Professional%20Ajax HTTP/1.1Host: www.baidu.comUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)Gecko/20050225 Firefox/1.0.1Connection: Keep-Alive注意，为了将文本“Professional Ajax”作为URL的参数，需要编码处理其内容，将空格替换成%20，这称为URL编码（URL encoding），常用于HTTP的许多地方（JavaScript提供了内建的函数来处理URL编码和解码）。“名称—值”（name—value）对用 &amp; 隔开。绝大部分的服务器端技术能够自动对请求主体进行解码，并为这些值的访问提供一些逻辑方式。当然，如何使用这些数据还是由服务器决定的。另一方面，POST请求在请求主体中为服务器提供了一些附加的信息。通常，当填写一个在线表单并提交它时，这些填入的数据将以POST请求的方式发送给服务器。以下就是一个典型的POST请求：POST / HTTP/1.1Host: www.baidu.comUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)Gecko/20050225 Firefox/1.0.1Content-Type: application/x-www-form-urlencodedContent-Length: 40Connection: Keep-Alivename=Professional%20Ajax&amp;publisher=Wiley从上面可以发现， POST请求和GET请求之间有一些区别。首先，请求行开始处的GET改为了POST，以表示不同的请求类型。你会发现首部Host和User-Agent仍然存在，在后面有两个新行。其中首部Content-Type说明了请求主体的内容是如何编码的。浏览器始终以application/ x-www-form- urlencoded的格式编码来传送数据，这是针对简单URL编码的MIME类型。首部Content-Length说明了请求主体的字节数。在首部Connection后是一个空行，再后面就是请求主体。与大多数浏览器的POST请求一样，这是以简单的“名称—值”对的形式给出的，其中name是Professional Ajax，publisher是Wiley。你可以以同样的格式来组织URL的查询字符串参数。下面是一些最常见的请求头： Accept：浏览器可接受的MIME类型。 Accept - Charset：浏览器可接受的字符集。 Accept - Encoding：浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间。 Accept - Language：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到。 Authorization：授权信息，通常出现在对服务器发送的WWW - Authenticate头的应答中。 Connection：表示是否需要持久连接。如果Servlet看到这里的值为“Keep - Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content - Length头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小。 Content - Length：表示请求消息正文的长度。 Cookie：这是最重要的请求头信息之一，参见后面《Cookie处理》一章中的讨论。 From：请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它。 Host：初始URL中的主机和端口。 If - Modified - Since：只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回304“Not Modified”应答。 Pragma：指定“no - cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝。 Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。 User - Agent：浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用。 UA - Pixels，UA - Color，UA - OS，UA - CPU：由某些版本的IE浏览器所发送的非标准的请求头，表示屏幕大小、颜色深度、操作系统和CPU类型。HTTP响应如下所示，HTTP响应的格式与请求的格式十分类似：&lt;status-line&gt;&lt;headers&gt;&lt;blank line&gt;[&lt;response-body&gt;]正如你所见，在响应中唯一真正的区别在于第一行中用状态信息代替了请求信息。状态行（status line）通过提供一个状态码来说明所请求的资源情况。以下就是一个HTTP响应的例子：HTTP/1.1 200 OKDate: Sat, 31 Dec 2005 23:59:59 GMTContent-Type: text/html;charset=ISO-8859-1Content-Length: 122&lt;html&gt;&lt;head&gt;&lt;title&gt;Wrox Homepage&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- body goes here --&gt;&lt;/body&gt;&lt;/html&gt;在本例中，状态行给出的HTTP状态代码是200，以及消息OK。状态行始终包含的是状态码和相应的简短消息，以避免混乱。最常用的状态码有：◆200 (OK): 找到了该资源，并且一切正常。◆304 (NOT MODIFIED): 该资源在上次请求之后没有任何修改。这通常用于浏览器的缓存机制。◆401 (UNAUTHORIZED): 客户端无权访问该资源。这通常会使得浏览器要求用户输入用户名和密码，以登录到服务器。◆403 (FORBIDDEN): 客户端未能获得授权。这通常是在401之后输入了不正确的用户名或密码。◆404 (NOT FOUND): 在指定的位置不存在所申请的资源。 js window.onload 和 jq ready 函数有何不同12345678910111213141.执行时间 window.onload必须等到页面内包括图片的所有元素加载完毕后才能执行。 $(document).ready()是DOM结构绘制完毕后就执行，不必等到加载完毕。 2.编写个数不同 window.onload不能同时编写多个，如果有多个window.onload方法，只会执行一个 $(document).ready()可以同时编写多个，并且都可以得到执行 3.简化写法 window.onload没有简化写法 $(document).ready(function()&#123;&#125;)可以简写成$(function()&#123;&#125;); jq 选中所有段落内部的div标签123456子元素选择器（&gt;），例如 $(&quot;div&gt;img&quot;) 获取div下的img子元素；遍历函数children()，例如 $(&quot;div&quot;).children(&quot;img&quot;) 同样是获取div下的img子元素。如果想要获取DIV下的不仅是子元素，而且还包括其他后代元素（孙辈、曾孙辈元素...），那么，相应的两种方法是：后代元素选择器（空格），例如 $(&quot;div img&quot;) 获取div下的所有级别的img后代元素；遍历函数find()，例如 $(&quot;div&quot;).find(&quot;img&quot;) 获取div下的所有级别的ing后代子元素。 jq 的选择器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091jQuery 的选择器可谓之强大无比，这里简单地总结一下常用的元素查找方法 $(&quot;#myELement&quot;) 选择id值等于myElement的元素，id值不能重复在文档中只能有一个id值是myElement所以得到的是唯一的元素 $(&quot;div&quot;) 选择所有的div标签元素，返回div元素数组 $(&quot;.myClass&quot;) 选择使用myClass类的css的所有元素 $(&quot;*&quot;) 选择文档中的所有的元素，可以运用多种的选择方式进行联合选择：例如$(&quot;#myELement,div,.myclass&quot;) 层叠选择器： $(&quot;form input&quot;) 选择所有的form元素中的input元素 $(&quot;#main &gt; *&quot;) 选择id值为main的所有的子元素 $(&quot;label + input&quot;) 选择所有的label元素的下一个input元素节点，经测试选择器返回的是label标签后面直接跟一个input标签的所有input标签元素 $(&quot;#prev ~ div&quot;) 同胞选择器，该选择器返回的为id为prev的标签元素的所有的属于同一个父元素的div标签 基本过滤选择器： $(&quot;tr:first&quot;) 选择所有tr元素的第一个 $(&quot;tr:last&quot;) 选择所有tr元素的最后一个 $(&quot;input:not(:checked) + span&quot;) 过滤掉：checked的选择器的所有的input元素 $(&quot;tr:even&quot;) 选择所有的tr元素的第0，2，4... ...个元素（注意：因为所选择的多个元素时为数组，所以序号是从0开始） $(&quot;tr:odd&quot;) 选择所有的tr元素的第1，3，5... ...个元素 $(&quot;td:eq(2)&quot;) 选择所有的td元素中序号为2的那个td元素 $(&quot;td:gt(4)&quot;) 选择td元素中序号大于4的所有td元素 $(&quot;td:ll(4)&quot;) 选择td元素中序号小于4的所有的td元素 $(&quot;:header&quot;) $(&quot;div:animated&quot;) 内容过滤选择器： $(&quot;div:contains(&apos;John&apos;)&quot;) 选择所有div中含有John文本的元素 $(&quot;td:empty&quot;) 选择所有的为空（也不包括文本节点）的td元素的数组 $(&quot;div:has(p)&quot;) 选择所有含有p标签的div元素 $(&quot;td:parent&quot;) 选择所有的以td为父节点的元素数组 可视化过滤选择器： $(&quot;div:hidden&quot;) 选择所有的被hidden的div元素 $(&quot;div:visible&quot;) 选择所有的可视化的div元素 属性过滤选择器： $(&quot;div[id]&quot;) 选择所有含有id属性的div元素 $(&quot;input[name=&apos;newsletter&apos;]&quot;) 选择所有的name属性等于&apos;newsletter&apos;的input元素 $(&quot;input[name!=&apos;newsletter&apos;]&quot;) 选择所有的name属性不等于&apos;newsletter&apos;的input元素 $(&quot;input[name^=&apos;news&apos;]&quot;) 选择所有的name属性以&apos;news&apos;开头的input元素 $(&quot;input[name$=&apos;news&apos;]&quot;) 选择所有的name属性以&apos;news&apos;结尾的input元素 $(&quot;input[name*=&apos;man&apos;]&quot;) 选择所有的name属性包含&apos;news&apos;的input元素 $(&quot;input[id][name$=&apos;man&apos;]&quot;) 可以使用多个属性进行联合选择，该选择器是得到所有的含有id属性并且那么属性以man结尾的元素 子元素过滤选择器： $(&quot;ul li:nth-child(2)&quot;),$(&quot;ul li:nth-child(odd)&quot;),$(&quot;ul li:nth-child(3n + 1)&quot;) $(&quot;div span:first-child&quot;) 返回所有的div元素的第一个子节点的数组 $(&quot;div span:last-child&quot;) 返回所有的div元素的最后一个节点的数组 $(&quot;div button:only-child&quot;) 返回所有的div中只有唯一一个子节点的所有子节点的数组 表单元素选择器： $(&quot;:input&quot;) 选择所有的表单输入元素，包括input, textarea, select 和 button $(&quot;:text&quot;) 选择所有的text input元素 $(&quot;:password&quot;) 选择所有的password input元素 $(&quot;:radio&quot;) 选择所有的radio input元素 $(&quot;:checkbox&quot;) 选择所有的checkbox input元素 $(&quot;:submit&quot;) 选择所有的submit input元素 $(&quot;:image&quot;) 选择所有的image input元素 $(&quot;:reset&quot;) 选择所有的reset input元素 $(&quot;:button&quot;) 选择所有的button input元素 $(&quot;:file&quot;) 选择所有的file input元素 $(&quot;:hidden&quot;) 选择所有类型为hidden的input元素或表单的隐藏域 表单元素过滤选择器： $(&quot;:enabled&quot;) 选择所有的可操作的表单元素 $(&quot;:disabled&quot;) 选择所有的不可操作的表单元素 $(&quot;:checked&quot;) 选择所有的被checked的表单元素 $(&quot;select option:selected&quot;) 选择所有的select 的子元素中被selected的元素 选取一个 name 为”S_03_22″的input text框的上一个td的text值$(”input[@ name =S_03_22]“).parent().prev().text() 名字以”S_”开始，并且不是以”_R”结尾的$(”input[@ name ^=&apos;S_&apos;]“).not(”[@ name $=&apos;_R&apos;]“) 一个名为 radio_01的radio所选的值$(”input[@ name =radio_01][@checked]“).val();]]></content>
      <categories>
        <category>Problem</category>
      </categories>
      <tags>
        <tag>Problem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP和HTTPS]]></title>
    <url>%2F2016%2F12%2F19%2Fhello-world%2F</url>
    <content type="text"><![CDATA[HTTP协议（HyperText Transfer Protocol，超文本传输协议）：是一种发布和接收 HTML页面的方法。 HTTPS（Hypertext Transfer Protocol over Secure Socket Layer）简单讲是HTTP的安全版，在HTTP下加入SSL层 SSL（Secure Sockets Layer 安全套接层）主要用于Web的安全传输协议，在传输层对网络连接进行加密，保障在Internet上数据传输的安全。 HTTP的端口号为80， HTTPS的端口号为443 URL（Uniform / Universal Resource Locator的缩写）：统一资源定位符，是用于完整地描述Internet上网页和其他资源的地址的一种标识方法。 基本格式：scheme://host[:port#]/path/…/[?query-string][#anchor] scheme：协议(例如：http, https, ftp) host：服务器的IP地址或者域名 port#：服务器的端口（如果是走协议默认端口，缺省端口80） path：访问资源的路径 query-string：参数，发送给http服务器的数据 anchor：锚（跳转到网页的指定锚点位置） e.g. ftp://192.168.0.116:8080/index https://www.baidu.com 客户端HTTP请求URL只是标识资源的位置，而HTTP是用来提交和获取资源。客户端发送一个HTTP请求到服务器的请求消息，包括以下格式： 请求行 请求头部 空行 请求方法1GET https://www.baidu.com/ HTTP/1.1 根据HTTP标准，HTTP请求可以使用多种请求方法。 HTTP 0.9：只有基本的文本 GET 功能。 HTTP 1.0：完善的请求/响应模型，并将协议补充完整，定义了三种请求方法： GET, POST 和 HEAD方法。 HTTP 1.1：在 1.0 基础上进行更新，新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。 HTTP 2.0（未普及）：请求/响应首部的定义基本没有改变，只是所有首部键必须全部小写，而且请求行要独立为 :method、:scheme、:host、:path这些键值对。 GET 请求指定的页面信息，并返回实体主体。 HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件），数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 PUT 从客户端向服务器传送的数据取代指定的文档的内容。 DELETE 请求服务器删除指定的页面。 CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 OPTIONS 允许客户端查看服务器的性能。 TRACE 回显服务器收到的请求，主要用于测试或诊断。 常见的HTTP状态码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831xx:信息100 Continue服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。101 Switching Protocols服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。2xx:成功200 OK请求成功（其后是对GET和POST请求的应答文档）201 Created请求被创建完成，同时新的资源被创建。202 Accepted供处理的请求已被接受，但是处理未完成。203 Non-authoritative Information文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝。204 No Content没有新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。205 Reset Content没有新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。206 Partial Content客户发送了一个带有Range头的GET请求，服务器完成了它。3xx:重定向300 Multiple Choices多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。301 Moved Permanently所请求的页面已经转移至新的url。302 Moved Temporarily所请求的页面已经临时转移至新的url。303 See Other所请求的页面可在别的url下被找到。304 Not Modified未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。305 Use Proxy客户请求的文档应该通过Location头所指明的代理服务器提取。306 Unused此代码被用于前一版本。目前已不再使用，但是代码依然被保留。307 Temporary Redirect被请求的页面已经临时移至新的url。4xx:客户端错误400 Bad Request服务器未能理解请求。401 Unauthorized被请求的页面需要用户名和密码。401.1登录失败。401.2服务器配置导致登录失败。401.3由于 ACL 对资源的限制而未获得授权。401.4筛选器授权失败。401.5ISAPI/CGI 应用程序授权失败。401.7访问被 Web 服务器上的 URL 授权策略拒绝。这个错误代码为 IIS 6.0 所专用。402 Payment Required此代码尚无法使用。403 Forbidden对被请求页面的访问被禁止。403.1执行访问被禁止。403.2读访问被禁止。403.3写访问被禁止。403.4要求 SSL。403.5要求 SSL 128。403.6IP 地址被拒绝。403.7要求客户端证书。403.8站点访问被拒绝。403.9用户数过多。403.10配置无效。403.11密码更改。403.12拒绝访问映射表。403.13客户端证书被吊销。403.14拒绝目录列表。403.15超出客户端访问许可。403.16客户端证书不受信任或无效。403.17客户端证书已过期或尚未生效。403.18在当前的应用程序池中不能执行所请求的 URL。这个错误代码为 IIS 6.0 所专用。403.19不能为这个应用程序池中的客户端执行 CGI。这个错误代码为 IIS 6.0 所专用。403.20Passport 登录失败。这个错误代码为 IIS 6.0 所专用。404 Not Found服务器无法找到被请求的页面。404.0没有找到文件或目录。404.1无法在所请求的端口上访问 Web 站点。404.2Web 服务扩展锁定策略阻止本请求。404.3MIME 映射策略阻止本请求。405 Method Not Allowed请求中指定的方法不被允许。406 Not Acceptable服务器生成的响应无法被客户端所接受。407 Proxy Authentication Required用户必须首先使用代理服务器进行验证，这样请求才会被处理。408 Request Timeout请求超出了服务器的等待时间。409 Conflict由于冲突，请求无法被完成。410 Gone被请求的页面不可用。411 Length Required&quot;Content-Length&quot; 未被定义。如果无此内容，服务器不会接受请求。412 Precondition Failed请求中的前提条件被服务器评估为失败。413 Request Entity Too Large由于所请求的实体的太大，服务器不会接受请求。414 Request-url Too Long由于url太长，服务器不会接受请求。当post请求被转换为带有很长的查询信息的get请求时，就会发生这种情况。415 Unsupported Media Type由于媒介类型不被支持，服务器不会接受请求。416 Requested Range Not Satisfiable服务器不能满足客户在请求中指定的Range头。417 Expectation Failed执行失败。423锁定的错误。5xx:服务器错误500 Internal Server Error请求未完成。服务器遇到不可预知的情况。500.12应用程序正忙于在 Web 服务器上重新启动。500.13Web 服务器太忙。500.15不允许直接请求 Global.asa。500.16UNC 授权凭据不正确。这个错误代码为 IIS 6.0 所专用。500.18URL 授权存储不能打开。这个错误代码为 IIS 6.0 所专用。500.100内部 ASP 错误。501 Not Implemented请求未完成。服务器不支持所请求的功能。502 Bad Gateway请求未完成。服务器从上游服务器收到一个无效的响应。502.1CGI 应用程序超时。 ·502.2CGI 应用程序出错。503 Service Unavailable请求未完成。服务器临时过载或当机。504 Gateway Timeout网关超时。505 HTTP Version Not Supported服务器不支持请求中指明的HTTP协议版本]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[data_structure]]></title>
    <url>%2F2016%2F12%2F19%2Fdata-structure%2F</url>
    <content type="text"><![CDATA[[转载]作者：LeeLom链接：http://www.jianshu.com/p/7d037c332a9d來源：简书 数据结构常见的八大排序算法（详细整理） 性能比较 交换排序快速排序算法思想 快速排序的基本思想：挖坑填数+分治法从序列当中选择一个基准数(pivot)在这里我们选择序列当中第一个数最为基准数将序列当中的所有数依次遍历，比基准数大的位于其右侧，比基准数小的位于其左侧重复步骤1.2，直到所有子集当中只有一个元素为止。用伪代码描述如下：1．i =L; j = R; 将基准数挖出形成第一个坑a[i]。2．j–由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。3．i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。4．再重复执行2，3二步，直到i==j，将基准数填入a[i]中 代码实现 123456789101112131415161718192021222324252627282930#快速排序#L：待排序的序列；start排序的开始index,end序列末尾的index#对于长度为length的序列：start = 0;end = length-1def quick_sort(L,start,end): if start &lt; end: i , j , pivot = start , end , L[start] while i &lt; j:#从右开始向左寻找第一个小于pivot的值 while (i &lt; j) and (L[j] &gt;= pivot): j = j-1#将小于pivot的值移到左边 if (i &lt; j): L[i] = L[j] i = i+1 #从左开始向右寻找第一个大于pivot的值 while (i &lt; j) and (L[i] &lt; pivot): i = i+1#将大于pivot的值移到右边 if (i &lt; j): L[j] = L[i] j = j-1#循环结束后，说明 i=j，此时左边的值全都小于pivot,右边的值全都大于pivot#pivot的位置移动正确，那么此时只需对左右两侧的序列调用此函数进一步排序即可#递归调用函数：依次对左侧序列：从0 ~ i-1//右侧序列：从i+1 ~ end L[i] = pivot#左侧序列继续排序 quick_sort(L,start,i-1)#右侧序列继续排序 quick_sort(L,i+1,end) 冒泡排序算法思想 冒泡排序思路比较简单：将序列当中的左右元素，依次比较，保证右边的元素始终大于左边的元素；（ 第一轮结束后，序列最后一个元素一定是当前序列的最大值；）对序列当中剩下的n-1个元素再次执行步骤1。对于长度为n的序列，一共需要执行n-1轮比较（利用while循环可以减少执行次数） 代码实现 12345678910111213#冒泡排序def bubble_sort(L): length = len(L)#序列长度为length，需要执行length-1轮交换 for x in range(1,length):#对于每一轮交换，都将序列当中的左右元素进行比较#每轮交换当中，由于序列最后的元素一定是最大的，因此每轮循环到序列未排序的位置即可 for i in range(0,length-x): if L[i] &gt; L[i+1]: temp = L[i] L[i] = L[i+1] L[i+1] = temp 插入排序 算法想想: 直接插入排序的核心思想就是：将数组中的所有元素依次跟前面已经排好的元素相比较，如果选择的元素比已排序的元素小，则交换，直到全部元素都比较过。因此，从上面的描述中我们可以发现，直接插入排序可以用两个循环完成： 第一层循环：遍历待比较的所有数组元素第二层循环：将本轮选择的元素(selected)与已经排好序的元素(ordered)相比较。如果：selected &gt; ordered，那么将二者交换 代码 123456789101112#直接插入排序def insert_sort(L): #遍历数组中的所有元素，其中0号索引元素默认已排序，因此从1开始 for x in range(1,len(L)): #将该元素与已排序好的前序数组依次比较，如果该元素小，则交换 #range(x-1,-1,-1):从x-1倒序循环到0 for i in range(x-1,-1,-1): #判断：如果符合条件则交换 if L[i] &gt; L[i+1]: temp = L[i+1] L[i+1] = L[i] L[i] = temp 希尔排序 算法想想: 希尔排序的算法思想：将待排序数组按照步长gap进行分组，然后将每组的元素利用直接插入排序的方法进行排序；每次将gap折半减小，循环上述操作；当gap=1时，利用直接插入，完成排序。同样的：从上面的描述中我们可以发现：希尔排序的总体实现应该由三个循环完成： 第一层循环：将gap依次折半，对序列进行分组，直到gap=1第二、三层循环：也即直接插入排序所需要的两次循环。具体描述见上。代码 代码 123456789101112131415161718#希尔排序def insert_shell(L): #初始化gap值，此处利用序列长度的一般为其赋值 gap = (int)(len(L)/2) #第一层循环：依次改变gap值对列表进行分组 while (gap &gt;= 1): #下面：利用直接插入排序的思想对分组数据进行排序 #range(gap,len(L)):从gap开始 for x in range(gap,len(L)): #range(x-gap,-1,-gap):从x-gap开始与选定元素开始倒序比较，每个比较元素之间间隔gap for i in range(x-gap,-1,-gap): #如果该组当中两个元素满足交换条件，则进行交换 if L[i] &gt; L[i+gap]: temp = L[i+gap] L[i+gap] = L[i] L[i] =temp #while循环条件折半 gap = (int)(gap/2) 选择排序简单选择排序 算法思想 简单选择排序的基本思想：比较+交换 从待排序序列中，找到关键字最小的元素；2.如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；3.从余下的 N - 1 个元素中，找出关键字最小的元素，重复(1)、(2)步，直到排序结束。因此我们可以发现，简单选择排序也是通过两层循环实现。第一层循环：依次遍历序列当中的每一个元素第二层循环：将遍历得到的当前元素依次与余下的元素进行比较，符合最小元素的条件，则交换。 代码 1234567891011121314# 简单选择排序def select_sort(L):#依次遍历序列中的每一个元素 for x in range(0,len(L)):#将当前位置的元素定义此轮循环当中的最小值 minimum = L[x]#将该元素与剩下的元素依次比较寻找最小元素 for i in range(x+1,len(L)): if L[i] &lt; minimum: temp = L[i]; L[i] = minimum; minimum = temp#将比较后得到的真正的最小值赋值给当前位置 L[x] = minimum 堆排序 堆的概念堆：本质是一种数组对象。特别重要的一点性质：任意的叶子节点小于（或大于）它所有的父节点。对此，又分为大顶堆和小顶堆，大顶堆要求节点的元素都要大于其孩子，小顶堆要求节点元素都小于其左右孩子，两者对左右孩子的大小关系不做任何要求。利用堆排序，就是基于大顶堆或者小顶堆的一种排序方法。下面，我们通过大顶堆来实现。 思想 堆排序可以按照以下步骤来完成： 首先将序列构建称为大顶堆；（这样满足了大顶堆那条性质：位于根节点的元素一定是当前序列的最大值） 2.取出当前大顶堆的根节点，将其与序列末尾元素进行交换；（此时：序列末尾的元素为已排序的最大值；由于交换了元素，当前位于根节点的堆并不一定满足大顶堆的性质） 3.对交换后的n-1个序列元素进行调整，使其满足大顶堆的性质； 4.重复2.3步骤，直至堆中只有1个元素为止 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#-------------------------堆排序--------------------------------#**********获取左右叶子节点**********def LEFT(i): return 2*i + 1def RIGHT(i): return 2*i + 2#********** 调整大顶堆 **********#L:待调整序列 length: 序列长度 i:需要调整的结点def adjust_max_heap(L,length,i):#定义一个int值保存当前序列最大值的下标 largest = i#执行循环操作：两个任务：1 寻找最大值的下标；2.最大值与父节点交换 while (1):#获得序列左右叶子节点的下标 left,right = LEFT(i),RIGHT(i)#当左叶子节点的下标小于序列长度 并且 左叶子节点的值大于父节点时，将左叶子节点的下标赋值给largest if (left &lt; length) and (L[left] &gt; L[i]): largest = left print('左叶子节点') else: largest = i#当右叶子节点的下标小于序列长度 并且 右叶子节点的值大于父节点时，将右叶子节点的下标值赋值给largest if (right &lt; length) and (L[right] &gt; L[largest]): largest = right print('右叶子节点')#如果largest不等于i 说明当前的父节点不是最大值，需要交换值 if (largest != i): temp = L[i] L[i] = L[largest] L[largest] = temp i = largest print(largest) continue else: break#********** 建立大顶堆 **********def build_max_heap(L): length = len(L) for x in range((int)((length-1)/2),-1,-1): adjust_max_heap(L,length,x)#********** 堆排序 **********def heap_sort(L):#先建立大顶堆，保证最大值位于根节点；并且父节点的值大于叶子结点 build_max_heap(L)#i：当前堆中序列的长度.初始化为序列的长度 i = len(L)#执行循环：1. 每次取出堆顶元素置于序列的最后(len-1,len-2,len-3...)# 2. 调整堆，使其继续满足大顶堆的性质，注意实时修改堆中序列的长度 while (i &gt; 0): temp = L[i-1] L[i-1] = L[0] L[0] = temp#堆中序列长度减1 i = i-1#调整大顶堆 adjust_max_heap(L,i,0) 归并排序 算法思想: 1.归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用分治法的一个典型的应用。它的基本操作是：将已有的子序列合并，达到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。 2.归并排序其实要做两件事： 分解—-将序列每次折半拆分 合并—-将划分后的序列段两两排序合并因此，归并排序实际上就是两个操作，拆分+合并 3.如何合并？L[first…mid]为第一段，L[mid+1…last]为第二段，并且两端已经有序，现在我们要将两端合成达到L[first…last]并且也有序。 首先依次从第一段与第二段中取出元素比较，将较小的元素赋值给temp[] 重复执行上一步，当某一段赋值结束，则将另一段剩下的元素赋值给temp[] 此时将temp[]中的元素复制给L[]，则得到的L[first…last]有序 4.如何分解？在这里，我们采用递归的方法，首先将待排序列分成A,B两组；然后重复对A、B序列 分组；直到分组后组内只有一个元素，此时我们认为组内所有元素有序，则分组结束。 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445# 归并排序#这是合并的函数# 将序列L[first...mid]与序列L[mid+1...last]进行合并def mergearray(L,first,mid,last,temp):#对i,j,k分别进行赋值 i,j,k = first,mid+1,0#当左右两边都有数时进行比较，取较小的数 while (i &lt;= mid) and (j &lt;= last): if L[i] &lt;= L[j]: temp[k] = L[i] i = i+1 k = k+1 else: temp[k] = L[j] j = j+1 k = k+1#如果左边序列还有数 while (i &lt;= mid): temp[k] = L[i] i = i+1 k = k+1#如果右边序列还有数 while (j &lt;= last): temp[k] = L[j] j = j+1 k = k+1#将temp当中该段有序元素赋值给L待排序列使之部分有序 for x in range(0,k): L[first+x] = temp[x]# 这是分组的函数def merge_sort(L,first,last,temp): if first &lt; last: mid = (int)((first + last) / 2)#使左边序列有序 merge_sort(L,first,mid,temp)#使右边序列有序 merge_sort(L,mid+1,last,temp)#将两个有序序列合并 mergearray(L,first,mid,last,temp)# 归并排序的函数def merge_sort_array(L):#声明一个长度为len(L)的空列表 temp = len(L)*[None]#调用归并排序 merge_sort(L,0,len(L)-1,temp) 基数排序 算法思想 1.基数排序：通过序列中各个元素的值，对排序的N个元素进行若干趟的“分配”与“收集”来实现排序。分配：我们将L[i]中的元素取出，首先确定其个位上的数字，根据该数字分配到与之序号相同的桶中收集：当序列中所有的元素都分配到对应的桶中，再按照顺序依次将桶中的元素收集形成新的一个待排序列L[ ]对新形成的序列L[]重复执行分配和收集元素中的十位、百位…直到分配完该序列中的最高位，则排序结束2.根据上述“基数排序”的展示，我们可以清楚的看到整个实现的过程 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#************************基数排序****************************#确定排序的次数#排序的顺序跟序列中最大数的位数相关def radix_sort_nums(L): maxNum = L[0]#寻找序列中的最大数 for x in L: if maxNum &lt; x: maxNum = x#确定序列中的最大元素的位数 times = 0 while (maxNum &gt; 0): maxNum = (int)(maxNum/10) times = times+1 return times#找到num从低到高第pos位的数据def get_num_pos(num,pos): return ((int)(num/(10**(pos-1))))%10#基数排序def radix_sort(L): count = 10*[None] #存放各个桶的数据统计个数 bucket = len(L)*[None] #暂时存放排序结果#从低位到高位依次执行循环 for pos in range(1,radix_sort_nums(L)+1): #置空各个桶的数据统计 for x in range(0,10): count[x] = 0 #统计当前该位(个位，十位，百位....)的元素数目 for x in range(0,len(L)): #统计各个桶将要装进去的元素个数 j = get_num_pos(int(L[x]),pos) count[j] = count[j]+1 #count[i]表示第i个桶的右边界索引 for x in range(1,10): count[x] = count[x] + count[x-1] #将数据依次装入桶中 for x in range(len(L)-1,-1,-1): #求出元素第K位的数字 j = get_num_pos(L[x],pos) #放入对应的桶中，count[j]-1是第j个桶的右边界索引 bucket[count[j]-1] = L[x] #对应桶的装入数据索引-1 count[j] = count[j]-1 # 将已分配好的桶中数据再倒出来，此时已是对应当前位数有序的表 for x in range(0,len(L)): L[x] = bucket[x]]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql_advanced]]></title>
    <url>%2F2016%2F12%2F11%2Fmysql-advanced%2F</url>
    <content type="text"><![CDATA[[TOC] 5 MySQL高级 本节课程学习MySQL数据库的高级操作，这些操作主要是由DBA或项目经理来完成，对于初级开发人员，不需要熟练操作，这部分内容作为了解，对于未来的工作是加分项账户管理：创建账户、修改密码、分配权限等存储过程：创建、删除、查看存储过程函数：创建、删除、查看函数，mysql中定义变量、选择语句、循环语句视图：完成查询语句的封装事务：保证一个业务逻辑的完整性索引：对于大数据量可以提高查询速度练习：根据性格测试的数据设计表，并编写创建表的脚本 账户管理 在生产环境下操作数据库时，绝对不可以使用root账户连接，而是创建特定的账户，授予这个账户特定的操作权限，然后连接进行操作，主要的操作就是数据的crudMySQL账户体系：根据账户所具有的权限的不同，MySQL的账户可以分为以下几种服务实例级账号：，启动了一个mysqld，即为一个数据库实例；如果某用户如root,拥有服务实例级分配的权限，那么该账号就可以删除所有的数据库、连同这些库中的表数据库级别账号：对特定数据库执行增删改查的所有操作数据表级别账号：对特定表执行增删改查等所有操作字段级别的权限：对某些表的特定字段进行操作存储程序级别的账号：对存储程序进行增删改查的操作账户的操作主要包括创建账户、删除账户、修改密码、授权权限等注意：进行账户操作时，需要使用root账户登录，这个账户拥有最高的实例级权限下面主要演示数据库级操作权限，因为通常都使用这种方式 查看所有用户 desc user\G; 创建账户并授予权限 grant 权限列表 on 数据库 to &#39;用户名&#39;@&#39;访问主机&#39; identified by &#39;密码&#39;; 授权 grant 权限名称 on 数据库 to 账户1,账户2,... with grant option; ###示例 step1：使用root登录 mysql -uroot -p回车后写密码，然后回车 step2: 用户名为tony，密码为mysql 操作python数据库的所有对象python.* 访问主机通常使用百分号%表示此账户可以使用任何ip的主机登录访问此数据库 访问主机可以设置成localhost或具体的ip，表示只允许本机或特定主机访问 grant all privileges on python.* to &#39;tony&#39;@&#39;%&#39; identified by &#39;mysql&#39;; 查看用户有哪些权限 show grant for tony step3：退出root的登录 quit 回收权限 语法如下： revoke 权限列表 on 数据库名.* from &#39;用户名&#39;@&#39;主机&#39;; 示例 step1：使用py登录后，向表classes中插入数据python3 use python; insert into classes(name) values(&#39;python3&#39;); step2：退出py quit step3：回收insert权限 revoke insert on python.* from &#39;py&#39;@&#39;%&#39;; step4：退出root quit 权限回收,inset失效 修改密码 语法1：不需登录修改密码 mysqladmin -u py -p password &#39;新密码&#39;例：mysqladmin -u py -p password &#39;123456&#39;回车后写密码，然后回车 语法2：使用root登录，修改mysql数据库的user表 update user set authentication_string=password(&#39;新密码&#39;) where user=&#39;用户名&#39;;例：update user set authentication_string=password(&#39;123&#39;) where user=&#39;py&#39;;刷新权限：flush privileges 删除账户 语法1：使用root登录 drop user &#39;用户名&#39;@&#39;主机&#39;;例：drop user &#39;py&#39;@&#39;%&#39;; 语法2：使用root登录，删除mysql数据库的user表中数据 这种方法还要删除db_mysql中的user表 delete from user where user=&#39;用户名&#39;;例：delete from user where user=&#39;py&#39;;– 操作结束之后需要刷新权限flush privileges 忘记 root 账户密码怎么办 !_! 去更改配置文件,实现免密登陆root账户,在重置密码 SQL注入攻击(数据安全)简介 SQL注入攻击是黑客对数据库进行攻击的常用手段之一。随着B/S模式应用开发的发展，使用这种模式编写应用程序的程序员也越来越多。但是由于程序员的水平及经验也参差不齐，相当大一部分程序员在编写代码的时候，没有对用户输入数据的合法性进行判断，使应用程序存在安全隐患。用户可以提交一段数据库查询代码，根据程序返回的结果，获得某些他想得知的数据，这就是所谓的SQL Injection，即SQL注入。 SQL注入攻击属于数据库安全攻击手段之一，可以通过数据库安全防护技术实现有效防护，数据库安全防护技术包括：数据库漏扫、数据库加密、数据库防火墙、数据脱敏、数据库安全审计系统。 SQL注入攻击会导致的数据库安全风险包括：刷库、拖库、撞库。 ###刷库 黑客通过入侵网站或内部运维人员多次从数据库中窃取新的用户资料和敏感信息的行为。现在的刷库方法，从开发公司开始渗透，从分站的C段开始渗透，社工目标方公司，社工目标方管理人员（google那些ID的资料）。其中用到的东西，目标方的习惯（文件夹文件名命名习惯，目标方的重要邮箱，目标方的MSN，电话，管理人员的资料，MSN，MSN密码，目标方用的安全软件等等）大杀器我见过很多了，office系列，pdf等社工邮件，一个接一个。没有大杀器的，就用chm木马，lnk后门，自解压包，不要以为这些方法很容易识破，但就是可以。我社工国内某目标，用的就是自解压包搞掂的。 拖库 拖库本来是数据库领域的术语，指从数据库中导出数据。到了黑客攻击泛滥的今天，它被用来指网站遭到入侵后，黑客窃取其数据库。 撞库 撞库是黑客通过收集互联网已泄露的用户和密码信息，生成对应的字典表，尝试批量登陆其他网站后，得到一系列可以登录的用户。很多用户在不同网站使用的是相同的帐号密码，因此黑客可以通过获取用户在A网站的账户从而尝试登录B网址，这就可以理解为撞库攻击。 提及“撞库”，就不能不说“脱库”和“洗库”。 在黑客术语里面，”脱库“是指黑客入侵有价值的网络站点，把注册用户的资料数据库全部盗走的行为，因为谐音，也经常被称作“脱库”，360的库带计划，奖励提交漏洞的白帽子，也是因此而得名。在取得大量的用户数据之后，黑客会通过一系列的技术手段和黑色产业链将有价值的用户数据变现，这通常也被称作“洗库”。最后黑客将得到的数据在其它网站上进行尝试登陆，叫做”撞库“，因为很多用户喜欢使用统一的用户名密码，”撞库“也可以使黑客收获颇丰。 函数创建 语法如下 `delimiter $$create function 函数名称(参数列表) returns 返回类型beginsql语句end $$delimiter ;` 说明：delimiter用于设置分割符，默认为分号 在“sql语句”部分编写的语句需要以分号结尾，此时回车会直接执行，所以要创建存储过程前需要指定其它符号作为分割符，此处使用//，也可以使用其它字符 示例 要求：创建函数py_trim，用于删除字符串左右两侧的空格 step1：设置分割符 delimiter $$ step2：创建函数 create function py_trim(str varchar(100)) returns varchar(100) begin declare x varchar(100); set x=ltrim(rtrim(str)); return x; end $$ step3：还原分割符 delimiter ; 查看 所有函数存储在mysql数据库下的proc表中 说明：存储过程与函数都存储在proc表中，区别在type字段，func表中无数据 查看python数据库中的函数 select name,type from mysql.proc where db=&#39;python&#39;; 调用 语法如下 select 函数名称(参数列表); 示例 要求：调用自定义函数py_trim select py_trim(&#39; a b c &#39;); 删除 说明：函数的代码无法修改，如果不能满足要求可以删除后重新创建 语法如下 drop function 函数名称; 示例 要求：删除函数py_trim drop function py_trim; 变量临时变量 声明临时变量，只能在 begin … end 体重语法如下 declare 变量名 类型 default 默认值; 例： declare x varchar(100); 设置变量值，语法如下 set 变量名=值; 例： set x=&#39;abc’; 用户变量/会话变量 只有在当前连接用户有效,其他连接用户无法访问 使用@标识声明用户变量 使用 select 来查看用户变量 定义 -- set @变量名 = 值; set @age = 20; -- 查看用户变量 select @age; -- 但是如果在 select 语句中这么使用就会有问题, 因为 &#39;=&#39; 在 select 语句中是判断是否相等 -- mysql 使用 := 在 select 语句中表示赋值 set @maxage = 0; select @maxage := max(age) from students; ####系统变量 任何一个用户都可以访问 使用 @@来标识系统变量 使用 select 来查看系统变量 -- 查询所有的系统变量 show variables; -- 查看系统变量 select @@max_connections; -- 当前用户/会话中修改系统变量 set max_connections = 1000; -- 全局修改,所有的访问用户都会生效 set global max_connection = 1000; 综合示例 要求：定义函数odd，输出1-100间的偶数 代码 ： delimiter $$ create function odd () returns varchar(300) begin declare i int default 1; declare x varchar(300) default &#39;&#39;; while i &lt;=100 do if i%2=0 then set x=concat(x,&#39; &#39;,i); end if; set i=i+1; end while; return x; end $$ delimiter ; 调用函数 select odd(); 刷新 flush privileges; 存储过程 存储过程，也翻译为存储程序，是一条或者多条SQL语句的集合，可以视为批处理，但是其作用不仅仅局限于批处理 本节主要介绍如何创建存储过程，以及如何调用、查看、修改、删除存储过程 存储过程也可以调用其他存储过程 推荐阅读：存储过程详解 创建 语法如下 delimiter // create procedure 存储过程名称(参数列表) begin sql语句 end // delimiter ; 说明：delimiter用于设置分割符，默认为分号 在“sql语句”部分编写的语句需要以分号结尾，此时回车会直接执行，所以要创建存储过程前需要指定其它符号作为分割符，此处使用//，也可以使用其它字符 示例 要求：创建查询过程，查询学生信息 code: delimiter // create procedure proc_stu() begin select * from students; end // delimiter ; 执行效果图如下: 查看 所有存储过程和函数，都存储在mysql数据库下的proc表中 查看表结构 主要字段说明： name表示名称 type表示类型，为存储过程、函数 body表示正文脚本 db表示属于的数据库 查看python数据库的所有存储过程 select name,type,body from mysql.proc where db=&#39;python&#39;; 调用 语法如下 call 存储过程(参数列表); 要求：调用存储过程proc_stu call proc_stu(); 删除 语法如下 drop procedure 存储过程名称; 要求：删除存储过程proc_stu drop procedure proc_stu; 存储过程和函数的区别 相同点 存储过程和函数都是为了可重复的执行操作数据库的 sql 语句的集合. 存储过程和函数都是一次编译,就会被缓存起来,下次使用就直接命中缓存中已经编译好的 sql, 不需要重复编译 减少网络交互,减少网络访问流量 不同点 标识符不同,函数的标识符是 function, 过程:procedure 函数中有返回值,且必须有返回值,而过程没有返回值,但是可以通过设置参数类型(in,out)来实现多个参数或者返回值 函数使用 select 调用,存储过程需要使用 call 调用 select 语句可以在存储过中调用,但是除了 select … into 之外的 select 语句都不能再函数中调用 通过 in out 参数,过程相关函数更加灵活,可以返回多个结果 在实际开发中根据个人喜好选择使用函数或者存储过程]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-primary]]></title>
    <url>%2F2016%2F12%2F10%2Fmysql-primary%2F</url>
    <content type="text"><![CDATA[[TOC] 服务器端安装 安装服务器端：在终端中输入如下命令，回车后，然后按照提示输入 sudo apt-get install mysql-server 启动服务 sudo service mysql start 停止服务 sudo service mysql stop 重启服务 sudo service mysql restart 配置 配置文件目录为/etc/mysql/mysql.cnf 主要配置项如下 bind-address表示服务器绑定的ip，默认为127.0.0.1 port表示端口，默认为3306 datadir表示数据库目录，默认为/var/lib/mysql general_log_file表示普通日志，默认为/var/log/mysql/mysql.log log_error表示错误日志，默认为/var/log/mysql/error.log 客户端图形化界面客户端navicat 进入解压的目录，运行如下命令 ./start_navicat 问题一：中文乱码 解决：打开start_navicat文件 将export LANG=&quot;en_US.UTF-8&quot;改为export LANG=&quot;zh_CN.UTF-8&quot; 问题二：试用期 解决：删除用户目录下的.navicat64目录 cd ~ rm -r .navicat64 详细连接的命令可以查看帮助文档 命令行连接 在工作中主要使用命令操作方式，要求熟练编写 打开终端，运行命令 mysql -uroot -p 回车后输入密码 或后面直接加您的密码 登录成功后，输入如下命令查看效果 查看版本：select version(); 显示当前时间：select now(); 数据库 查看所有数据库 show databases; 使用数据库 use 数据库名; 查看当前使用的数据库 select database(); 创建数据库 create database 数据库名 charset=utf8; 删除数据库 drop database python; 数据表 查看当前数据库中所有表 show tables; 查看表结构 desc 表名; 创建表 auto_increment表示自动增长 12345678CREATE TABLE table_name( column1 datatype contrai, column2 datatype, column3 datatype, ..... columnN datatype, PRIMARY KEY(one or more columns)); `– 例：创建班级表create table classes( id int unsigned auto_increment primary key not null, name varchar(10)); 例：创建学生表 create table students( id int unsigned primary key auto_increment not null, name varchar(20) default &#39;&#39;, age tinyint unsigned default 0, height decimal(5,2), gender enum(&#39;男&#39;,&#39;女&#39;,&#39;人妖&#39;,&#39;保密&#39;), cls_id int unsigned default 0 ) 修改表-添加字段 alter table students add birthday datetime; 修改表-修改字段：重命名版 table 表名 change 原名 新名 类型及约束;12例：alter table students change birthday birth datetime not null; 修改表-修改字段：不重命名版 alter table 表名 modify 列名 类型及约束; 例：alter table students modify birth date not null; 修改表-删除字段 alter table 表名 drop 列名; 例：alter table students drop birthday; 查看表的创建语句 show create table 表名; 例：show create table classes; 增删改查(curd)查询基本使用 查询所有列 select * from 表名; 例：select * from classes; 查询指定列 可以使用as为列或表指定别名 select 列1,列2,… from 表名; 例：select id,name from classes; 增加 insert into students values(0,’郭靖‘,1,&#39;蒙古&#39;,&#39;2016-1-2&#39;); insert into classes values(0,’python1’),(0,’python2’); insert into students(name) values(‘杨康’),(‘杨过’),(‘小龙女’); 修改 update students set gender=0,hometown=’古墓’ where id=5; 删除 delete from students where id=5; 备份 mysqldump –uroot –p 数据库名 &gt; python.sql; 恢复 mysql -uroot –p 新数据库名 &lt; python.sql 聚合函数 例1：查询学生总数 select count(*) from students; 例2：查询女生的编号最大值 select max(id) from students where gender=0; 例3：查询未删除的学生最小编号 select min(id) from students where isdelete=0; 例4：查询男生的编号之和 select sum(id) from students where gender=1; 例5：查询未删除女生的编号平均值 select avg(id) from students where isdelete=0 and gender=0; ##分组 例1：查询男女生总数 select gender as 性别,count(*)from studentsgroup by gender; 对比where与having where是对from后面指定的表进行数据筛选，属于对原始数据的筛选 having是对group by的结果进行筛选 分页 语法 select * from 表名limit start,count select * from studentswhere gender=1limit 0,3; 子查询(sub query)标量子查询 查询班级学生的平均身高 select * from students where age &gt; (select avg(age) from students); 列级子查询 查询还有学生在班的所有班级名字 select name from pythons where id in (select cls_id from students); 行级子查询 需求: 查找班级年龄最大,身高最高的学生 select * from students where (height,age) = (select max(height),max(age) from students); 表级子查询 查询学生与班级对应的信息 select from(select stu.,pys.name as clsname from students as stu inner join pythons as pys on stu.cls_id = pys.id)as t1; 子查询中特定关键字使用 in any|some SELECT * FROM classes WHERE id = any(SELECT DISTINCT cls_id FROM students); all SELECT * from classes WHERE id != ALL (SELECT DISTINCT cls_id FROM students WHERE cls_id BETWEEN 2 and 4); ##完整sql语句 SELECT select_expr [,select_expr,...] [ FROM tb_name [WHERE 条件判断] [GROUP BY {col_name | postion} [ASC | DESC], ...] [HAVING WHERE 条件判断] [ORDER BY {col_name|expr|postion} [ASC | DESC], ...] [ LIMIT {[offset,]rowcount | row_count OFFSET offset}] ] select distinct * from 表名 where .... group by ... having ... order by ... limit start,count]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[section]]></title>
    <url>%2F2016%2F08%2F13%2Fsection%2F</url>
    <content type="text"><![CDATA[1234取一个list或tuple的部分元素是非常常见的操作。比如，一个list如下：&gt;&gt;&gt; L = [&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;, &apos;Bob&apos;, &apos;Jack&apos;]取前3个元素，应该怎么做？ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283笨办法：&gt;&gt;&gt; [L[0], L[1], L[2]][&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;]之所以是笨办法是因为扩展一下，取前N个元素就没辙了。取前N个元素，也就是索引为0-(N-1)的元素，可以用循环：&gt;&gt;&gt; r = []&gt;&gt;&gt; n = 3&gt;&gt;&gt; for i in range(n):... r.append(L[i])... &gt;&gt;&gt; r[&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;]对这种经常取指定索引范围的操作，用循环十分繁琐，因此，Python提供了切片（Slice）操作符，能大大简化这种操作。对应上面的问题，取前3个元素，用一行代码就可以完成切片：&gt;&gt;&gt; L[0:3][&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;]L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。如果第一个索引是0，还可以省略：&gt;&gt;&gt; L[:3][&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;]也可以从索引1开始，取出2个元素出来：&gt;&gt;&gt; L[1:3][&apos;Sarah&apos;, &apos;Tracy&apos;]类似的，既然Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片，试试：&gt;&gt;&gt; L[-2:][&apos;Bob&apos;, &apos;Jack&apos;]&gt;&gt;&gt; L[-2:-1][&apos;Bob&apos;]记住倒数第一个元素的索引是-1。切片操作十分有用。我们先创建一个0-99的数列：&gt;&gt;&gt; L = range(100)&gt;&gt;&gt; L[0, 1, 2, 3, ..., 99]可以通过切片轻松取出某一段数列。比如前10个数：&gt;&gt;&gt; L[:10][0, 1, 2, 3, 4, 5, 6, 7, 8, 9]后10个数：&gt;&gt;&gt; L[-10:][90, 91, 92, 93, 94, 95, 96, 97, 98, 99]前11-20个数：&gt;&gt;&gt; L[10:20][10, 11, 12, 13, 14, 15, 16, 17, 18, 19]前10个数，每两个取一个：&gt;&gt;&gt; L[:10:2][0, 2, 4, 6, 8]所有数，每5个取一个：&gt;&gt;&gt; L[::5][0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]甚至什么都不写，只写[:]就可以原样复制一个list：&gt;&gt;&gt; L[:][0, 1, 2, 3, ..., 99]tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple：&gt;&gt;&gt; (0, 1, 2, 3, 4, 5)[:3](0, 1, 2)字符串&apos;xxx&apos;或Unicode字符串u&apos;xxx&apos;也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：&gt;&gt;&gt; &apos;ABCDEFG&apos;[:3]&apos;ABC&apos;&gt;&gt;&gt; &apos;ABCDEFG&apos;[::2]&apos;ACEG&apos;在很多编程语言中，针对字符串提供了很多各种截取函数，其实目的就是对字符串切片。Python没有针对字符串的截取函数，只需要切片一个操作就可以完成，非常简单。小结有了切片操作，很多地方循环就不再需要了。Python的切片非常灵活，一行代码就可以实现很多行循环才能完成的操作。]]></content>
      <categories>
        <category>Problem</category>
      </categories>
      <tags>
        <tag>programming</tag>
      </tags>
  </entry>
</search>
